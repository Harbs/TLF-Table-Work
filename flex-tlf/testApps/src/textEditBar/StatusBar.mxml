<?xml version="1.0" encoding="utf-8"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<mx:HBox xmlns:mx="http://www.adobe.com/2006/mxml"
		addedToStage="onAddedToStage()" removedFromStage="onRemovedFromStage()"
		horizontalScrollPolicy="off" verticalScrollPolicy="off" width="100%">
	<mx:Metadata>
		<!-- event generated by this component -->
		[Event(name="change", type="textEditBar.StyleChangeEvent")]
		
		<!-- undocumented -->
		[DefaultTriggerEvent("change")]
	</mx:Metadata>
	<mx:Script>
		<![CDATA[
			import flash.system.Capabilities;
			
			import flashx.textLayout.edit.EditManager;
			import flashx.textLayout.edit.EditingMode;
			import flashx.textLayout.edit.ElementRange;
			import flashx.textLayout.edit.IEditManager;
			import flashx.textLayout.edit.ISelectionManager;
			import flashx.textLayout.elements.*;
			import flashx.undo.IUndoManager;
		
			private var saveUndoMaxStr:String;
            
            public var activeFlow:TextFlow;
			
			[Bindable]
			private var editingModeList:Array = [
				{ label:"ReadOnly", data:EditingMode.READ_ONLY },
				{ label:"ReadWrite", data:EditingMode.READ_WRITE  },
				{ label:"ReadSelect", data:EditingMode.READ_SELECT }
			]
			
			internal function editingModeSelectHandler(data:String):void
			{
				dispatchEvent(new StyleChangeEvent("editingMode",data));
			}
			
			private function setUndoItemsMax():void
			{
				// Format changed via GUI - push to the TextFlow
				if (activeFlow && activeFlow.interactionManager is EditManager)
				{
					var undoManager:IUndoManager = IEditManager(activeFlow.interactionManager).undoManager;
					if (undoManager)
					{
			 			undoManager.undoAndRedoItemLimit = int(undoItemsMax.text);
			 			updateUndoItemsMax(undoManager.undoAndRedoItemLimit);
			 		}
					// Force focus back to main text. There should be a way to make the widget give up key
					// focus, but I couldn't find one. So we need to set it to the selection's container explicitly.
					activeFlow.interactionManager.setFocus();
				}
			}
			
			public function update(range:ElementRange):void
			{
 				var selectionManager:ISelectionManager = activeFlow  ? activeFlow.interactionManager : null;
 				var editManager:IEditManager = (selectionManager && (selectionManager is IEditManager)) ?
					IEditManager(selectionManager) : null;
				var undoManager:IUndoManager = editManager ? editManager.undoManager : null;
					
				updateEditingMode();
				updateUndoItemsMax(undoManager ? undoManager.undoAndRedoItemLimit : -1);
 		
				updateSelectionRange(selectionManager ? selectionManager.anchorPosition : -1,selectionManager ? selectionManager.activePosition : -1);
 				updateOverwriteText(editManager ? ((editManager is EditManager) ? (EditManager.overwriteMode ? "Overwrite Mode" : "Insert Mode") : "") : "");
			}
			private var onStage:Boolean = false;
			private var addedFrameEventListener:Boolean = false;
			
			private function onAddedToStage():void
			{
				// the dataProviders aren't set up yet - delay to the frame
				onStage = true;
				if (!addedFrameEventListener)
				{
					addedFrameEventListener = true;
					addEventListener("enterFrame",onEnterFrame);
				}
			}
			
			private function onEnterFrame(p:Event):void
			{
				this.removeEventListener("enterFrame",onEnterFrame);
				addedFrameEventListener = false;
				
				update(null);
			}
			
			private function onRemovedFromStage():void
			{
				onStage = false;
			}
			
			private var previousEditingMode:String;

			private function updateEditingMode():void
			{
				var activeInteractionManager:ISelectionManager = activeFlow.interactionManager;
				var editingMode:String = activeInteractionManager ? ((activeInteractionManager is IEditManager) ? EditingMode.READ_WRITE : EditingMode.READ_SELECT) : EditingMode.READ_ONLY
				if (editingMode == previousEditingMode)
					return;
				
				previousEditingMode = editingMode;
				
				var idx:int = 0;
				for (idx = 0; idx < editingModeList.length; idx++)
				{
					var obj:Object = editingModeList[idx];
					if (obj.data == editingMode)
					{
						editingModeBox.selectedIndex = idx;
						return;
					}
				}
				editingModeBox.selectedIndex = -1;
			}
			
			private var previousNewItemsMax:int = 0;
    		private var previousOverwriteMode:String = "Insert";
    		private var tabDisplayed:Boolean = false;
			
			public function updateUndoItemsMax(newItemsMax:int):void
			{
				if (onStage)
				{
					if ((ExternalInterface.available) && (Capabilities.playerType != "PlugIn") && (Capabilities.playerType != "ActiveX"))
					{
						if (!tabDisplayed)
						{
							removeChild(undoItemsMaxLabel);
							removeChild(undoItemsMax);
						}
					}
					else
					{
						undoItemsMax.text = saveUndoMaxStr = newItemsMax.toString();					
					}
					tabDisplayed = true;
				}
				previousNewItemsMax = newItemsMax;
			}
			
			public function updateOverwriteText(s:String):void
			{
				if (onStage)
				{
					overwrite.text = s;
				}
				previousOverwriteMode = s;
			}
			
			private var anchorIdx:int = -1;
			private var activeIdx:int = -1;
			
			public function updateSelectionRange(anchor:int,active:int):void
			{
				anchorIdx = anchor;
				activeIdx = active;
				if (onStage)
					selection.text = "Sel: (" + anchorIdx.toString() + "," + activeIdx.toString() + ")";
				
				generateAncestorList(anchorIdx == activeIdx ? activeIdx : -1);
			}
			
			private function onFocusOut():void
			{
				undoItemsMax.text=saveUndoMaxStr
			}
			
			
			[Bindable]
			public var ancestorList:Array = [];
			
			
			private var _ancestorListIndex:int;
			
			private function generateAncestorList(pos:int):void
			{
				var elementName:String;
				ancestorList.length = 0;
				var element:FlowElement = activeFlow.findLeaf(pos);
				while (element)
				{
					if (element is SpanElement)
						elementName = "span";
					else if (element is InlineGraphicElement)
						elementName = "img";
					else if (element is TCYElement)
						elementName = "tcy";
					else if (element is LinkElement)
						elementName = "link";
					else if (element is ParagraphElement)
						elementName = "paragraph";
					else if (element is ListItemElement)
						elementName = "listItem";
					else if (element is ListElement)
						elementName = "list";
					else if (element is DivElement)
						elementName = "div";
					else if (element is TextFlow)
						elementName = "textFlow";
					else if (element is BreakElement)
						elementName = "br";
					else if (element is TabElement)
						elementName = "tab";
					else
						elementName = "UNKNONW";
					ancestorList.push(elementName);
					element = element.parent;
				}
			}
			
			public function setTargetElement():void
			{
				trace("Set target element", targetElementMenu.selectedIndex);
				var element:FlowElement = activeFlow.findLeaf(activeFlow.interactionManager.activePosition);
				var index:int = targetElementMenu.selectedIndex;
				while (index-- > 0 && element)
					element = element.parent;

				dispatchEvent(new StyleChangeEvent("targetElement",element));
			}
	
		]]>
	</mx:Script>
	<mx:Label id="swfVersion" text="SwfVersion:UNK" fontWeight="bold" paddingTop="3" paddingBottom="1"/>
	
	<mx:Label id="undoItemsMaxLabel" text="Max Undo/Redo Items:"/> 
	<mx:TextInput id="undoItemsMax" width="30" focusOut="onFocusOut()" 
		enter="setUndoItemsMax();"
		keyFocusChange="setUndoItemsMax();"/>
	<mx:Label id="selection" text="Sel: (#xxxxxx,#xxxxxx)"  paddingTop="3" paddingBottom="1"/>
	<mx:Label id="overwrite" text="Insert Mode" fontWeight="bold" paddingTop="3" paddingBottom="1"/>
	<mx:ComboBox id="editingModeBox" dataProvider="{editingModeList}" close="if (ComboBox(event.target).selectedItem) editingModeSelectHandler(ComboBox(event.target).selectedItem.data)" selectedIndex="-1"/>
	<mx:ComboBox id="targetElementMenu" dataProvider="{ancestorList}" editable="false" 
				 selectedIndex="0" 
				 close="setTargetElement()" />
</mx:HBox>
