<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			 xmlns:s="library://ns.adobe.com/flex/spark" 
			 xmlns:mx="library://ns.adobe.com/flex/mx" 
			 
			 minWidth="955" minHeight="600" 
			 applicationComplete="importApplicationCompleteHandler(event)">
	
	<fx:Style>
		@namespace s "library://ns.adobe.com/flex/spark";
		@namespace mx "library://ns.adobe.com/flex/mx";
		
		.header {
			fontSize: 12;
			fontWeight: normal;
			backgroundColor: #E6E6E6;
			color: #565656;
			paddingTop: 6;
			paddingBottom: 4;
			paddingLeft: 4;
			paddingRight: 4;
		}
	</fx:Style>
	
	<fx:Declarations>
		<fx:XML id="simpleTextMarkup">
			<TextFlow fontSize="11" paddingLeft="8" paddingRight="8" paddingTop="8" whiteSpaceCollapse="collapse" version="3.0.0" xmlns="http://ns.adobe.com/textLayout/2008">
				<p>
					<span>A un Angleso it va semblar un simplificat Angles, quam un skeptic Cambridge amico dit me que Occidental es.Li Europan lingues es membres del sam familie. Lor separat existentie es un myth. Por scientie, musica, sport etc, litot Europa usa li sam vocabular. Li lingues differe solmen in li grammatica, li pronunciation e li plu commun vocabules. Omnicos directe al desirabilite de un nov lingua franca: On refusa continuar payar custosi traductores. At solmen va esser necessi far uniform grammatica, pronunciation e plu sommun paroles. </span>
				</p>
			</TextFlow>
		</fx:XML>
		
		<fx:XML id="complexTextFlow">
			<TextFlow fontSize="11" paddingLeft="8" paddingRight="8" paddingTop="8" whiteSpaceCollapse="collapse" version="3.0.0" xmlns="http://ns.adobe.com/textLayout/2008">
				<p>
					<img paddingRight="8" source="http://lh4.googleusercontent.com/-v0soe-ievYE/AAAAAAAAAAI/AAAAAAACTE4/HdLawjGMFsE/s120-c/photo.jpg" float="right"/>
					<span>A un Angleso it va semblar un simplificat Angles, quam un skeptic Cambridge amico dit me que Occidental es.Li Europan lingues es membres del sam familie. Lor separat existentie es un myth. Por scientie, musica, sport etc, litot Europa usa li sam vocabular. Li lingues differe solmen in li grammatica, li pronunciation e li plu commun vocabules. Omnicos directe al desirabilite de un nov lingua franca: On refusa continuar payar custosi traductores. At solmen va esser necessi far uniform grammatica, pronunciation e plu sommun paroles. </span>
				</p>
			</TextFlow>
		</fx:XML>
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import flash.text.engine.TextLine;
			import flash.utils.ByteArray;
			
			import flashx.textLayout.TextLayoutVersion;
			import flashx.textLayout.compose.TextFlowTableBlock;
			
			import mx.core.mx_internal;ByteArray
			
			import flashx.textLayout.formats.TextLayoutFormat;TextLayoutFormat
			
			import mx.core.IVisualElement;
			import mx.events.FlexEvent;
			
			import spark.components.Alert;
			import spark.core.SpriteVisualElement;
			import spark.events.TextOperationEvent;
			
			import flashx.textLayout.tlf_internal;
			import flashx.textLayout.compose.ComposeState;
			import flashx.textLayout.compose.IFlowComposer;
			import flashx.textLayout.compose.ParcelList;
			import flashx.textLayout.compose.StandardFlowComposer;
			import flashx.textLayout.compose.TextFlowLine;
			import flashx.textLayout.container.ColumnState;
			import flashx.textLayout.container.ContainerController;
			import flashx.textLayout.conversion.ITextExporter;
			import flashx.textLayout.conversion.ITextImporter;
			import flashx.textLayout.conversion.TextConverter;
			import flashx.textLayout.edit.EditManager;
			import flashx.textLayout.edit.ISelectionManager;
			import flashx.textLayout.edit.SelectionFormat;
			import flashx.textLayout.edit.SelectionManager;
			import flashx.textLayout.elements.Configuration;Configuration
			import flashx.textLayout.elements.FlowLeafElement;
			import flashx.textLayout.elements.InlineGraphicElement;
			import flashx.textLayout.elements.ParagraphElement;
			import flashx.textLayout.elements.SpanElement;
			import flashx.textLayout.elements.TableCellElement;
			import flashx.textLayout.elements.TableColElement;
			import flashx.textLayout.elements.TableElement;
			import flashx.textLayout.elements.TableRowElement;
			import flashx.textLayout.elements.TextFlow;
			import flashx.textLayout.events.CompositionCompleteEvent;
			import flashx.textLayout.events.FlowElementMouseEvent;
			import flashx.textLayout.events.ModelChange;
			import flashx.textLayout.events.SelectionEvent;
			import flashx.textLayout.events.StatusChangeEvent;
			import flashx.textLayout.formats.WhiteSpaceCollapse;WhiteSpaceCollapse
			import flashx.undo.UndoManager;
			
			use namespace tlf_internal;
			
			public var textFlow:TextFlow;
			public var container:SpriteVisualElement;
			public var controller:ContainerController;
			public var tableData:String;
			
			// embed table test
			[Embed(source="data/tableExample.xml",mimeType="application/octet-stream")]
			private var TableExample:Class;

			
			protected function importApplicationCompleteHandler(event:FlexEvent):void {
				var tableByte:ByteArray = new TableExample();
				tableData = tableByte.readMultiByte(tableByte.length,"utf-8");
				
				//textFlow = importer.importToFlow(tableData);
				importToFlow(simpleTextMarkup);
				
				
				clearTextFlow();
				
				versionInfo.text = "Vellum: " + flashx.textLayout.TextLayoutVersion.BUILD_NUMBER + (Configuration.tlf_internal::debugCodeEnabled ? " Debug" : " Release") 
					+ ", Flex: " + mx_internal::VERSION
					+ ", Player: " + Capabilities.version;
			}
			
			/******************************************************
			 * Table
			 *****************************************************/
			
			/**
			 * Adds a table to the text flow
			 **/
			public function addTable(rows:int = 1, columns:int = 1, selectable:Boolean = false, editable:Boolean = false):TableElement {
				var table:TableElement = new TableElement();
				var cell:TableCellElement;
				var option:Boolean;
				
				if (option) {
					cell = new TableCellElement();
					cell.textFlow = getTextFlowContent(null, selectable, editable);
					cell.colIndex = 0;
					cell.rowIndex = 0;
					
					table.numColumns = columns;
					table.addRow();
					table.addChild(cell);
					textFlow.addChild(table);
				}
				else {
					table.numColumns = columns;
					textFlow.addChild(table);
					
					for (var i:int = 0; i < rows; i++) {
						addRow(false);
					}
				}
				
				updateAllControllers();
				
				return table;
			}
			
			/**
			 * Adds a row to the table
			 **/
			public function addRow(updateControllers:Boolean = true):TableRowElement {
				var table:TableElement = getTable();
				
				if (!table) {
					table = addTable();
				}
				
				table.addRow();
				
				var rowIndex:int = table.numRows - 1;
				var columnCount:int = table.numColumns;
				var cell:TableCellElement;
				var cellTextFlow:TextFlow;
				var para:ParagraphElement;
				var span:SpanElement;
				var selectable:Boolean = textFlow.interactionManager is SelectionManager;
				var editable:Boolean = textFlow.interactionManager is EditManager;
				
				for(var i:int=0;i<columnCount;i++){
					cell = new TableCellElement();
					
					cell.colIndex = i;
					cell.rowIndex = rowIndex;
					cell.textFlow = getTextFlowContent("R " + rowIndex + " C " + cell.colIndex, selectable, editable);
					
					table.addChild(cell);
				}
				
				if (updateControllers) {
					updateAllControllers();
				}
				
				return table.getRowAt(rowIndex);
			}
			
			/**
			 * Adds a column to the table
			 **/
			public function addColumn():TableColElement {
				var table:TableElement = getTable();
				var columnIndex:int = table.numColumns;
				
				if (!table) {
					table = addTable();
				}
				
				table.addColumn();
				
				updateAllControllers();
				
				return table.getColumnAt(columnIndex);
			}
			
			/**
			 * Remove the selected table or last table in the text flow
			 **/
			public function removeTable():TableElement {
				var table:TableElement = getTable();
				
				if (table) {
					textFlow.removeChild(table);
				}
				
				updateAllControllers();
				return table;
			}
			
			/**
			 * Removes the selected row or the last row in the table
			 **/
			public function removeRow():TableRowElement {
				var table:TableElement = getTable();
				var rowElement:TableRowElement;
				
				if (table) {
					rowElement = table.removeRowAt(table.numRows - 1);
				}
				
				updateAllControllers();
				
				return rowElement;
			}
			
			/**
			 * Removes the selected column or last column in the table
			 **/
			public function removeColumn():TableColElement {
				var table:TableElement = getTable();
				var columnElement:TableColElement;
				
				if (table) {
					columnElement = table.removeColumnAt(table.numColumns - 1) as TableColElement;
				}
				
				updateAllControllers();
				
				return columnElement;
			}
			
			/**
			 * Selects the cell the cursor is in or the first cell in the table
			 **/
			public function selectCell():TableElement {
				var table:TableElement = getTable();
				
				if (table) {
					
				}
				
				return null;
			}
			
			/**
			 * Selects the specified cells
			 **/
			public function selectCells(cells:Array = null):TableElement {
				var table:TableElement = getTable();
				
				if (table) {
					
				}
				
				return null;
			}
			
			/**
			 * Selects a column in the table
			 **/
			public function selectColumn():TableElement {
				var table:TableElement = getTable();
				
				if (table) {
					
				}
				
				return null;
			}
			
			/**
			 * Selects a row in the table
			 **/
			public function selectRow(rowIndex:int = 0):TableElement {
				var table:TableElement = getTable();
				
				if (table) {
					
				}
				
				return null;
			}
			
			/**
			 * Joins contiguous separate cells into one cell
			 **/
			public function joinCells():TableElement {
				var table:TableElement = getTable();
				
				if (table) {
					
				}
				
				return null;
			}
			
			
			/******************************************************
			 * Bounds
			 *****************************************************/
			
			/**
			 * So the text line bounds. 
			 * There are a few types of fills and they all seem to differ. 
			 * There is: 
			 * - background color fill style created by the BackgroundManager. see addParagraph()
			 * - selection fill. select some text
			 * - this fill method based on what I found online
			 * - Label background fill. I don't think it uses BackgroundManager. 
			 **/
			public function showTextLineBounds():void
			{
				var i:int;
				var j:int;
				var b1:Rectangle;
				var b2:Rectangle;
				var fc:IFlowComposer = textFlow.flowComposer;
				var controller:ContainerController = textFlow.flowComposer.getControllerAt(0);
				var color:uint = 0x00dd00;
				var method:int = 0;
				var clearedOnce:Boolean;
				
				for (i = 0; i < fc.numLines; i++) {
					var _tfl:TextFlowLine = fc.getLineAt(i);
					var _tl:TextLine = _tfl.getTextLine();
					b1 = _tfl.getBounds();
					b2 = _tl.getBounds(_tfl.controller.container);
					
					if (method==1) {
						var g:Sprite = new Sprite;
						g.graphics.lineStyle(1, color, 0.6);
						g.graphics.drawRect(0, Math.max(-b1.height,-_tfl.height), b1.width, b1.height);
						_tl.removeChildren();
						_tl.addChild(g);
					}
					else {
						var graphics:Graphics = _tfl.controller.container.graphics;
						if (!clearedOnce && graphics.readGraphicsData().length!=0) {
							graphics.clear();
							clearedOnce = true;
						}
						graphics.beginFill(color);
						graphics.drawRect(b1.x, b1.y, b1.width, b1.height);
						graphics.endFill();
					}
				}
			}
			
			/**
			 * Shows the bounds of the atoms. This is from the TLF forums. 
			 **/
			public function showAtomBounds():void
			{
				var i:int;
				var j:int;
				var b1:Rectangle;
				var fc:IFlowComposer = textFlow.flowComposer;
				var color:uint = 0x00dd00;
				
				for (i = 0; i < fc.numLines; i++)
				{
					var _tfl:TextFlowLine = fc.getLineAt(i);
					var _tl:TextLine = _tfl.getTextLine();
					
					for (j = 0; j < _tl.atomCount; j++)
					{
						var textBlockBeginIndex:int = _tl.getAtomTextBlockBeginIndex(j);
						var textFlowPosition:int = _tfl.paragraph.getAbsoluteStart()+_tl.getAtomTextBlockBeginIndex(j);
						b1 = _tl.getAtomBounds(j);
						var g:Sprite = new Sprite;
						g.graphics.lineStyle(1, color,0.6)
						g.graphics.drawRect(b1.x, b1.y , b1.width, b1.height);
						_tl.addChild(g);
						
						var leafElement:FlowLeafElement = textFlow.findLeaf(textFlowPosition);
						var leafRelativePosition:int = textFlowPosition-leafElement.getAbsoluteStart();
						var leafCharacter:String = leafElement.text.substr(leafRelativePosition,1);
						//trace(i,j,textBlockBeginIndex,textFlowPosition,b1);
					}
				}
			}
			
			/**
			 * Show paragraph bounds. Example is from one of the AS3 examples in TLF-SDK directory 
			 **/
			public function showParagraphBounds():Rectangle {
				var bounds:Rectangle = new Rectangle();
				var paragraph:ParagraphElement = getParagraph();
				var container:ContainerController = paragraph.getEnclosingController(0);
				var sprite:Sprite = container.container;
				var pos:int = paragraph.getAbsoluteStart();
				var endPos:int = pos + paragraph.textLength;
				var color:int = 0x00FF00;
				
				while (pos < endPos) {
					var line:TextFlowLine = paragraph.getTextFlow().flowComposer.findLineAtPosition(pos);
					//bounds = bounds.union(line.getTextLine().getBounds(this));
					bounds = bounds.union(line.getTextLine().getBounds(sprite));
					pos += line.textLength;
				}
				
				sprite.graphics.clear();
				sprite.graphics.beginFill(color);
				sprite.graphics.drawRect(bounds.left, bounds.top, bounds.width, bounds.height);
				sprite.graphics.endFill();
				sprite.graphics.lineStyle(1, 0x0);
				sprite.graphics.moveTo(bounds.left - 1, bounds.top - 1);
				sprite.graphics.lineTo(bounds.right + 1, bounds.top - 1);
				sprite.graphics.lineTo(bounds.right + 1, bounds.bottom);
				sprite.graphics.lineTo(bounds.left - 1, bounds.bottom);
				sprite.graphics.lineTo(bounds.left - 1, bounds.top - 1);
				
				return bounds;
			}
			
			/**
			 * Show the bounds of the table. This is not working code. 
			 **/
			public function showTableBounds():Rectangle {
				var table:TableElement = getTable();
				
				if (!table) return null;
				
				// this does not work at this time
				var bounds:Rectangle = new Rectangle();
				var lineBounds:Rectangle = new Rectangle();
				var lineBounds2:Rectangle = new Rectangle();
				var container:ContainerController = table ? table.getEnclosingController(0) :null;
				var sprite:Sprite = container.container;
				var pos:int = table.getAbsoluteStart();
				var endPos:int = pos + table.textLength;
				var color:int = 0x00FF00;
				
				while (pos < endPos) {
					//var line:TextFlowTableBlock = table.getTextFlow().flowComposer.findLineAtPosition(pos) as TextFlowTableBlock;
					var line:TextFlowLine = table.getTextFlow().flowComposer.findLineAtPosition(pos);
					//bounds = bounds.union(line.getTextLine().getBounds(this));
					lineBounds = new Rectangle(line.x, line.y, line.targetWidth, line.height);
					lineBounds2 = line.getTextLine().getBounds(sprite);
					bounds = bounds.union(lineBounds2);
					pos += line.textLength;
				}
				
				var block:TextFlowTableBlock = table.getFirstBlock();
				bounds.y = block.y;
				bounds.width = block.container.width;
				bounds.height = block.height;
				
				sprite.graphics.clear();
				sprite.graphics.beginFill(color);
				sprite.graphics.drawRect(bounds.left, bounds.top, bounds.width, bounds.height);
				sprite.graphics.endFill();
				sprite.graphics.lineStyle(1, 0x0);
				sprite.graphics.moveTo(bounds.left - 1, bounds.top - 1);
				sprite.graphics.lineTo(bounds.right + 1, bounds.top - 1);
				sprite.graphics.lineTo(bounds.right + 1, bounds.bottom);
				sprite.graphics.lineTo(bounds.left - 1, bounds.bottom);
				sprite.graphics.lineTo(bounds.left - 1, bounds.top - 1);
				
				return bounds;
			}
			
			/**
			 * Attempt to show all parcels or regions available to a text flow or table.
			 * This is not working code.
			 **/
			public function showParcelBounds():void {
				var flowComposer:StandardFlowComposer = textFlow.flowComposer as StandardFlowComposer;
				var container:ContainerController = flowComposer.getControllerAt(flowComposer.numControllers-1);
				var columnState:ColumnState = container.columnState;
				var composeState:ComposeState = flowComposer.getComposeState();
				var parcelList:ParcelList = composeState.parcelList;
				var backgroundManager:Object = textFlow.getBackgroundManager();
				var blocks:Array = textFlow.getBackgroundManager()?textFlow.backgroundManager.getShapeRectArray():[];
				var selectionSprite:Sprite = container.getSelectionSprite(true) as Sprite;
				var backgroundSprite:Shape = container.getBackgroundShape() as Shape;
				
				return;
				var bounds:Rectangle = container.getContentBounds();
				var g:Graphics = backgroundSprite.graphics;
				g.clear();
				g.beginFill(0x00ff00);
				g.drawRect(bounds.left, bounds.top, bounds.width, bounds.height);
				g.endFill();
				g.lineStyle(1, 0x0);
				g.moveTo(bounds.left - 1, bounds.top - 1);
				g.lineTo(bounds.right + 1, bounds.top - 1);
				g.lineTo(bounds.right + 1, bounds.bottom);
				g.lineTo(bounds.left - 1, bounds.bottom);
				g.lineTo(bounds.left - 1, bounds.top - 1);
				
			}
			
			/******************************************************
			 * Selection
			 *****************************************************/
			
			public function highlightOneCharacter():void {
				var selObj:Shape = new Shape();
				
				var flowComposer:IFlowComposer = textFlow.flowComposer;
				var line:TextFlowLine = flowComposer.getLineAt(1);
				var selFormat:SelectionFormat = textFlow.interactionManager ? textFlow.interactionManager.currentSelectionFormat : null;
				//if (!selFormat) {
				selFormat = new SelectionFormat(0xFF0000, 1, "difference", 0xFF0000, 1, "difference");
				//}
				var selectionAbsoluteStart:int = 0;
				var selectionAbsoluteEnd:int = 1;
				var controller:ContainerController = flowComposer.getControllerAt(0);
				var container:Sprite = controller.container;
				
				controller.addSelectionShapes(selFormat, 0, 10);
				//line.hiliteBlockSelection(selObj, selFormat, textFlow.flowComposer.getControllerAt(0).container as DisplayObject, selectionAbsoluteStart, selectionAbsoluteEnd, null, null);
				
			}
			
			public function selectRange():void {
				var flowComposer:IFlowComposer = textFlow.flowComposer;
				textFlow.interactionManager = new SelectionManager;
				var interactionManager:ISelectionManager = textFlow.interactionManager;
				interactionManager.selectRange(10, 22); // this is not working? 
			}
			
			/******************************************************
			 * Misc
			 *****************************************************/
			
			/**
			 * Updates all controllers. Call after the text flow is modified in any way.
			 **/
			public function updateAllControllers():void {
				textFlow.flowComposer.updateAllControllers();
				
				exportTextFlow(textFlow);
				
				updateTableInformation();
			}
			
			/**
			 * Handles graphic status change events
			 **/
			public function graphicStatusChanged(event:StatusChangeEvent):void {
				var img:InlineGraphicElement = event.element as InlineGraphicElement;
				updateAllControllers();
				
				if (event.status == "ready" || event.status == "sizePending") {
					
					var mirror:IEventDispatcher = event.element.getEventMirror();
					mirror.addEventListener(FlowElementMouseEvent.MOUSE_DOWN,traceEvent);
					mirror.addEventListener(FlowElementMouseEvent.MOUSE_UP,traceEvent);
					mirror.addEventListener(FlowElementMouseEvent.MOUSE_MOVE,traceEvent);
					mirror.addEventListener(FlowElementMouseEvent.ROLL_OVER,traceEvent);
					mirror.addEventListener(FlowElementMouseEvent.ROLL_OUT,traceEvent);
					mirror.addEventListener(FlowElementMouseEvent.CLICK,traceEvent);
					
					updateAllControllers();
				}
			}
			
			/**
			 * Handler for model change events
			 **/
			public function elementModified(event:Event):void
			{
				//trace("event: " + event.type);
			}
			
			/**
			 * Used to check mouse events
			 **/
			public function traceEvent(event:FlowElementMouseEvent):void
			{
				//trace(event.flowElement.defaultTypeName+ " " + getTimer() + " " + event.toString() + event.originalEvent.toString());
				
				// attempt to add a cursor over an image / table
				if (event.type==FlowElementMouseEvent.ROLL_OVER || 
					event.type==FlowElementMouseEvent.MOUSE_MOVE) {
					Mouse.cursor = MouseCursor.HAND;
				}
				else if (event.type==FlowElementMouseEvent.ROLL_OUT) {
					Mouse.cursor = MouseCursor.AUTO;
				}
			}
			
			/**
			 * Adds a paragraph to the text flow
			 **/
			public function addParagraph(text:String = null):void {
				var paragraph:ParagraphElement = new ParagraphElement();
				var span:SpanElement = new SpanElement();
				
				if (text) {
					span.text = text;
				}
				else {
					span.text = "This is a paragraph \nSecond line.";
				}
				
				paragraph.backgroundAlpha = 0.2;
				paragraph.backgroundColor = 0x0000FF;
				
				paragraph.addChild(span);
				
				textFlow.addChild(paragraph);
				
				updateAllControllers();
			}
			
			/**
			 * Creates a text flow from the text value passed in. Used for table cell text flows.
			 **/
			public function getTextFlowContent(text:String = null, selectable:Boolean = false, editable:Boolean = false):TextFlow {
				var textFlowContent:TextFlow = new TextFlow();
				var paragraph:ParagraphElement = new ParagraphElement();
				var span:SpanElement = new SpanElement();
				
				if (text) {
					span.text = text;
				}
				else {
					span.text = "This is cell";
				}
				
				paragraph.backgroundAlpha = 0.2;
				paragraph.backgroundColor = 0xFF0000;
				paragraph.addChild(span);
				
				if (editable) {
					textFlowContent.interactionManager = new EditManager(new UndoManager);
				}
				else if (selectable) {
					textFlowContent.interactionManager = new SelectionManager();
				}
				
				textFlowContent.addChild(paragraph);
				
				return textFlowContent;
			}
			
			/**
			 * Gets the paragraph the cursor is in or the first available paragraph 
			 **/
			public function getParagraph():ParagraphElement {
				var paragraph:ParagraphElement;
				
				if (textFlow.interactionManager) {
					var cursor:int = Math.max(0, textFlow.interactionManager.anchorPosition);
					paragraph = textFlow.findAbsoluteParagraph(cursor);
				}
				
				if (!paragraph) {
					var items:Array = textFlow.getElementsByTypeName("p");
					paragraph = items.length ? items[0] : null;
				}
				
				return paragraph;
			}
			
			/**
			 * Gets the first table available or null if none are available
			 **/
			public function getTable():TableElement {
				var table:TableElement;
				
				if (textFlow.interactionManager) {
					var cursor:int = Math.max(0, textFlow.interactionManager.anchorPosition);
					//table = textFlow.findAbsoluteParagraph(cursor);
				}
				
				if (!table) {
					var items:Array = textFlow.getElementsByTypeName("table");
					table = items.length ? items[0] : null;
				}
				
				return table;
			}
			
			/**
			 * Removes the shapes added by show boundary methods
			 **/
			public function removeShapes():void {
				var paragraph:ParagraphElement = getParagraph();
				if (!paragraph) return;
				var bounds:Rectangle = new Rectangle();
				var container:ContainerController = paragraph.getEnclosingController(0);
				var sprite:Sprite = container.container;
				
				var i:int;
				var j:int;
				var b1:Rectangle;
				var fc:IFlowComposer = textFlow.flowComposer;
				var color:uint = 0x00dd00;
				
				for (i = 0; i < fc.numLines; i++)
				{
					var _tfl:TextFlowLine = fc.getLineAt(i);
					var _tl:TextLine = _tfl.getTextLine();
					_tl.removeChildren();
				}
				
				if (sprite && sprite.graphics.readGraphicsData().length!=0) {
					sprite.graphics.clear();
				}
			}
			
			/**
			 * Removes all the children in the text flow
			 **/
			public function clearTextFlow():void {
				//textFlow.setTextLength(0);
				//textFlow.deleteContainerText(0, textFlow.textLength);
				
				if (textFlow.numChildren) {
					textFlow.replaceChildren(0, textFlow.numChildren);
				}
				
				removeShapes();
				
				updateAllControllers();
				
				if (textFlow.interactionManager) {
					textFlow.interactionManager.selectAll();
					textFlow.interactionManager.setFocus();
				}
			}
			
			/**
			 * Flag indicating if currently importing text
			 * If the text flow has inline graphics that have not loaded yet it can cause
			 * another composition complete event causing a reexport.
			 **/
			public var updatingTextFlow:Boolean;

			/**
			 * Imports the text flow markup into new text flow content when changed.
			 * If the text flow has inline graphics that have not loaded yet it can cause
			 * another composition complete event causing a reexport. 
			 **/
			protected function textFlowMarkup_changeHandler(event:TextOperationEvent):void {
				updatingTextFlow = true;
				importToFlow(textFlowMarkup.text);
				updatingTextFlow = false;
			}
			
			/**
			 * Imports the text into a new text flow
			 **/
			public function importToFlow(value:String):TextFlow {
				var errors:Vector.<String>;
				var importer:ITextImporter;
				var newTextFlow:TextFlow;
				
				importer = TextConverter.getImporter(TextConverter.TEXT_LAYOUT_FORMAT);
				importer.throwOnError = false;
				
				//importer.configuration = new Configuration();
				newTextFlow = importer.importToFlow(value);
				errors = importer.errors;
				
				// if text flow is not null add it and ignore errors
				//if (!errors && newTextFlow) {
				if (newTextFlow) { 
					setupTextFlow(newTextFlow);
				}
				
				updateErrorsText(importer.errors);
				
				return newTextFlow;
			}
			
			/**
			 * Adds listeners to the text flow and adds it to the container
			 **/
			public function setupTextFlow(newTextFlow:TextFlow):void {
				if (!newTextFlow) return;
				
				// remove listeners from previous text flow
				// we may need to do other things to clear out the old textflow
				if (textFlow) {
					textFlow.removeEventListener(CompositionCompleteEvent.COMPOSITION_COMPLETE, compositionComplete);
					textFlow.removeEventListener(ModelChange.ELEMENT_MODIFIED, graphicStatusChanged);
					textFlow.removeEventListener(StatusChangeEvent.INLINE_GRAPHIC_STATUS_CHANGE, graphicStatusChanged);
					textFlow.removeEventListener(SelectionEvent.SELECTION_CHANGE, selectionChange);
				}
				
				textFlow = newTextFlow;
				
				textFlow.addEventListener(CompositionCompleteEvent.COMPOSITION_COMPLETE, compositionComplete, false, 0, true);
				textFlow.addEventListener(ModelChange.ELEMENT_MODIFIED, elementModified, false, 0, true);
				textFlow.addEventListener(StatusChangeEvent.INLINE_GRAPHIC_STATUS_CHANGE, graphicStatusChanged, false, 0, true);
				textFlow.addEventListener(SelectionEvent.SELECTION_CHANGE, selectionChange, false, 0, true);
				
				if (!container) {
					container = new SpriteVisualElement();
				}
				
				container.removeChildren();
				
				if (!controller) {
					controller = new ContainerController(container, group.width, group.height);
				}
				
				// Add controller to text flow; add container to stage and display text
				textFlow.flowComposer.addController(controller);
				
				//textFlow.interactionManager = new SelectionManager();
				textFlow.interactionManager = new EditManager(new UndoManager);
				
				group.addElement(container as IVisualElement);
				
				updateAllControllers();
			}
			
			/**
			 * When TextFlow has finished composition we export the markup
			 **/
			protected function compositionComplete(event:CompositionCompleteEvent):void
			{
				exportTextFlow(textFlow);
			}
			
			/**
			 * Selection change
			 **/
			protected function selectionChange(event:SelectionEvent):void
			{
				// not used yet
			}
			
			/**
			 * 
			 **/
			public function notImplemented():void
			{
				Alert.show("Not implemented", "Message");
			}
			
			/**
			 * Exports the text flow markup and reports any errors.
			 * Changes can be overwritten when using inline graphics
			 **/
			public function exportTextFlow(textFlow:TextFlow):void {
				
				// do not export if importing or user is typing into the text flow markup text area
				if (updatingTextFlow ||
					textFlowMarkup.focusManager.getFocus()==textFlowMarkup) {
					return;
				}
				
				
				var exporter:ITextExporter = TextConverter.getExporter(TextConverter.TEXT_LAYOUT_FORMAT);
				exporter.throwOnError = false;
				
				// we need to set white space to collapse to allow space bar to work in the text area
				// if we set the attribute manually it works
				// unfortunately I can't get it to export with collapse
				//textFlow.whiteSpaceCollapse = WhiteSpaceCollapse.COLLAPSE;
				//textFlow.setStyle("whiteSpaceCollapse", WhiteSpaceCollapse.COLLAPSE);
				//textFlow.flowComposer.updateAllControllers();
				/*
				var format:TextLayoutFormat = new TextLayoutFormat();
				format.whiteSpaceCollapse = WhiteSpaceCollapse.COLLAPSE;
				var config:Configuration = new Configuration();
				config.textFlowInitialFormat = format;*/
				
				var object:Object = exporter.export(textFlow, TextConverter.TEXT_LAYOUT_FORMAT);				
				textFlowMarkup.text = object is XML ? XML(object).toXMLString() : null;
				
				updateErrorsText(exporter.errors);
			}
			
			/**
			 * Adds errors during export or import to the errors text box
			 **/
			public function updateErrorsText(errors:Vector.<String>):void {
				textFlowMarkupErrors.text = errors ? errors.join("\n") : null;
			}
			
			private function updateTableInformation():void {
				var table:TableElement = getTable();
				
				if (table) {
					tableWidth.text = String(table.width);
					tableHeight.text = String(table.getFirstBlock().height);
					tableBlocks.text = table.tableBlocks ? String(table.tableBlocks.length) : "";
					tableCells.text = String(table.numCells);
					tableRows.text = String(table.numRows);
					tableColumns.text = String(table.numColumns);
				}
				else {
					tableWidth.text = "";
					tableHeight.text = "";
					tableBlocks.text = "";
					tableCells.text = "";
					tableRows.text = "";
					tableColumns.text = "";
				}
			}
			
		]]>
	</fx:Script>

	<s:HGroup width="100%" minHeight="400" top="50" left="10" right="10">
		<s:VGroup width="100%" height="100%">
			<s:HGroup width="100%" gap="1" >
				<s:Label text="TextFlow" width="100%" styleName="header"/>
				<s:Label text="clear" click="clearTextFlow()" 
						 styleName="header" 
						 useHandCursor="true" buttonMode="true"
						 />					
			</s:HGroup>  
			<s:BorderContainer id="group" width="100%" height="100%" minHeight="250"/>
			<s:Label text="TextFlow Markup" width="100%" styleName="header"/>
			<s:TextArea id="textFlowMarkup" width="100%" height="100%" 
						focusThickness="0" change="textFlowMarkup_changeHandler(event)"/>
			<s:Label text="TextFlow Markup Errors" width="100%" styleName="header"
						/>
			<s:TextArea id="textFlowMarkupErrors" width="100%" height="30%" color="red"
						/>
		</s:VGroup>
		<s:VGroup width="100%" height="100%">
			<s:Label text="Add Elements" width="100%" styleName="header"/>
			<s:HGroup>
				<mx:LinkButton label="Table" click="addTable(3, 3)"/>
				<mx:LinkButton label="Selectable Table" click="addTable(3, 3, true)"/>
				<mx:LinkButton label="Editable Table" click="addTable(3, 3, false, true)"/>
			</s:HGroup>
			<s:HGroup>
				<mx:LinkButton label="Row" click="addRow()"/>
				<mx:LinkButton label="Column" click="addColumn()"/>
				<mx:LinkButton label="Paragraph" click="addParagraph()"/>
			</s:HGroup>
			<s:Label text="Remove Elements" width="100%" styleName="header"/>
			<s:HGroup>
				<mx:LinkButton label="Table" click="removeTable()"/>
				<mx:LinkButton label="Row" click="removeRow()"/>
				<mx:LinkButton label="Column" click="removeColumn()"/>
				<mx:LinkButton label="Paragraph" />
				<mx:LinkButton label="Span" />
				<mx:LinkButton label="Shapes" click="removeShapes()"/>
				<mx:LinkButton label="All" click="clearTextFlow()"/>
			</s:HGroup>
			<s:Label text="Select Elements" width="100%" styleName="header"/>
			<s:HGroup>
				<mx:LinkButton label="Table" click="selectRange()"/>
				<mx:LinkButton label="Row" click="selectRow()"/>
				<mx:LinkButton label="Column" click="selectColumn()"/>
				<mx:LinkButton label="Cell" click="selectCell()"/>
				<mx:LinkButton label="Cells" click="selectCells()"/>
			</s:HGroup>
			<s:Label text="Show Boundaries" width="100%" styleName="header"/>
			<s:HGroup>
				<mx:LinkButton label="Paragraph" click="showParagraphBounds()"/>
				<mx:LinkButton label="Table" click="showTableBounds()"/>
				<mx:LinkButton label="Parcels" click="showParcelBounds()"/>
				<mx:LinkButton label="TextLines" click="showTextLineBounds()"/>
				<mx:LinkButton label="Atoms" click="showAtomBounds()"/>
			</s:HGroup>
			<s:Label text="Import" width="100%" styleName="header"/>
			<s:HGroup>
				<mx:LinkButton label="Table" click="importToFlow(tableData)"/>
				<mx:LinkButton label="Simple TextFlow" click="importToFlow(simpleTextMarkup)"/>
				<mx:LinkButton label="Complex TextFlow" click="importToFlow(complexTextFlow)"/>
			</s:HGroup>
			<s:Label text="Misc" width="100%" styleName="header"/>
			<s:HGroup>
				<mx:LinkButton label="Join Cells" click="joinCells()"/>
				<mx:LinkButton label="Select Range" click="selectRange()"/>
				<mx:LinkButton label="Update all controllers" click="updateAllControllers()"/>
			</s:HGroup>
			<s:Label text="Table Information" width="100%" styleName="header"/>
			<s:HGroup minHeight="22" verticalAlign="middle">
				<s:Label text="Width:" paddingLeft="10" />
				<s:Label id="tableWidth" /> 
				<s:Label text="Height:" />
				<s:Label id="tableHeight" />
				<s:Label text="Rows:" />
				<s:Label id="tableRows" />
				<s:Label text="Columns:" />
				<s:Label id="tableColumns" />
				<s:Label text="Total Cells:" />
				<s:Label id="tableCells" />
				<s:Label text="Blocks:" />
				<s:Label id="tableBlocks" />
			</s:HGroup>
			<s:Label text="Version Information" width="100%" styleName="header"/>
			<s:HGroup minHeight="22" verticalAlign="middle">
				<s:Label id="versionInfo" paddingLeft="10"/>
			</s:HGroup>
		</s:VGroup>
	</s:HGroup>
	
</s:Application>
