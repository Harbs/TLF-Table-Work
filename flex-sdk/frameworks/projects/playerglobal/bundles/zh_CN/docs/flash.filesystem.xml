<?xml version="1.0" encoding="UTF-8"?>
<!--

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

-->
<apiPackage xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" id="flash.filesystem" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiPackage/apiPackage "><apiName class="- topic/title reference/title apiRef/apiName ">flash.filesystem</apiName><apiDetail class="- topic/body reference/refbody apiRef/apiDetail "/><apiClassifier languages="" id="flash.filesystem:FileStream" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiClassifier/apiClassifier "><apiName class="- topic/title reference/title apiRef/apiName ">FileStream</apiName><shortdesc class="- topic/shortdesc ">
 使用 FileStream 对象读取和写入文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiClassifierDetail class="- topic/body reference/refbody apiRef/apiDetail apiClassifier/apiClassifierDetail "><apiClassifierDef class="- topic/section reference/section apiRef/apiDef apiClassifier/apiClassifierDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier class="- topic/xref reference/xref apiRef/apiRelation apiClassifier/apiBaseClassifier ">flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 使用 FileStream 对象读取和写入文件。通过调用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法可以同步打开文件，通过调用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法可以异步打开文件。
 
 <p class="- topic/p ">以异步方式打开文件的好处是当 Adobe AIR 在后台运行读写过程时，可以执行其他代码。在以异步方式打开文件时，将随着操作的进行调度 <codeph class="+ topic/ph pr-d/codeph ">progress</codeph> 事件。</p>
 
 <p class="- topic/p ">以同步方式打开的 File 对象其行为很类似于 ByteArray 对象；以异步方式打开的文件其行为很类似于 Socket 或 URLStream 对象。在以同步方式打开 File 对象时，当从基础文件中读取或向其中写入需要的数据时，调用方将暂停。在以异步方式打开文件时，将会立即缓冲写入到流的任何数据，然后再写入文件。</p>
 
 <p class="- topic/p ">无论是以同步方式还是以异步方式从文件中读取数据，实际的读取方法都是同步的。两种情况都读取当前“可用的”数据。不同之处在于在以同步方式读取时，所有数据始终是可用的；而在以异步方式读取时，随着数据流入读取缓冲区，数据将逐渐变为可用。无论哪种方式，可以在当前时刻以同步方式读取的数据将用 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性表示。</p>
 
 <p class="- topic/p ">处理异步输入的应用程序通常会注册 <codeph class="+ topic/ph pr-d/codeph ">progress</codeph> 事件并使用通过调用读取方法变为可用的数据。或者，应用程序可以通过注册 <codeph class="+ topic/ph pr-d/codeph ">complete</codeph> 事件并处理调度 <codeph class="+ topic/ph pr-d/codeph ">complete</codeph> 事件时的整个数据集，从而简单地等待所有数据变为可用。 </p>
 
 </apiDesc></apiClassifierDetail><adobeApiEvent id="flash.filesystem:FileStream_flash.events.Event.COMPLETE_complete" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">complete</apiName><shortdesc class="- topic/shortdesc ">
 指出已到达流末尾。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 指出已到达流末尾。
 
 </apiDesc></adobeApiEventDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/position" class="- topic/link "><linktext class="- topic/linktext ">position</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.OutputProgressEvent.OUTPUT_PROGRESS_outputProgress" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">outputProgress</apiName><shortdesc class="- topic/shortdesc ">
 指出已将缓冲数据写入文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.OutputProgressEvent.OUTPUT_PROGRESS</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.OutputProgressEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 指出已将缓冲数据写入文件。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.ProgressEvent.PROGRESS_progress" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">progress</apiName><shortdesc class="- topic/shortdesc ">
 指出流上有可用的新数据。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 指出流上有可用的新数据。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.IOErrorEvent.IO_ERROR_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><shortdesc class="- topic/shortdesc ">
 表示在异步文件 I/O 操作期间发生错误。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 表示在异步文件 I/O 操作期间发生错误。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.Event.CLOSE_close" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">close</apiName><shortdesc class="- topic/shortdesc ">
 表示 close() 方法的显式调用已关闭流。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 表示 <codeph class="+ topic/ph pr-d/codeph ">close()</codeph> 方法的显式调用已关闭流。
 
 </apiDesc></adobeApiEventDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/close()" class="- topic/link "><linktext class="- topic/linktext ">close()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.filesystem:FileStream:FileStream" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation apiOperation/apiConstructor"><apiName class="- topic/title reference/title apiRef/apiName ">FileStream</apiName><shortdesc class="- topic/shortdesc ">
	 创建 FileStream 对象。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiConstructorDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail apiOperation/apiConstructorDetail"><apiConstructorDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiConstructorDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/></apiConstructorDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 创建 FileStream 对象。使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法打开文件。
	 
	 </apiDesc></apiConstructorDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/open()" class="- topic/link "><linktext class="- topic/linktext ">open()</linktext></link><link href="flash.filesystem.xml#FileStream/openAsync()" class="- topic/link "><linktext class="- topic/linktext ">openAsync()</linktext></link></related-links></apiConstructor><apiOperation id="flash.filesystem:FileStream:close" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">close</apiName><shortdesc class="- topic/shortdesc ">
	 关闭 FileStream 对象。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 关闭 FileStream 对象。 
	 
	 <p class="- topic/p ">在调用 <codeph class="+ topic/ph pr-d/codeph ">close()</codeph> 方法后将无法读取或写入任何数据。如果以异步方式打开该文件（FileStream 对象使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法打开该文件），则调用 <codeph class="+ topic/ph pr-d/codeph ">close()</codeph> 方法将导致该对象调度 <codeph class="+ topic/ph pr-d/codeph ">close</codeph> 事件。 </p>
	 
	 <p class="- topic/p ">关闭应用程序将自动关闭与该应用程序中的 FileStream 对象相关联的所有文件。不过，最好在关闭应用程序之前，对以异步方式打开并具有要写入的未处理数据的所有 FileStream 对象注册 <codeph class="+ topic/ph pr-d/codeph ">closed</codeph> 事件（以确保写入数据）。</p>
	 
	 <p class="- topic/p ">通过调用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法可以重复使用 FileStream 对象。这将关闭与 FileStream 对象相关联的任何文件，但该对象不会调度 <codeph class="+ topic/ph pr-d/codeph ">close</codeph> 事件。</p>
	 
	 <p class="- topic/p ">对于以异步方式打开的 FileStream 对象（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法），即使为 FileStream 对象调用了 <codeph class="+ topic/ph pr-d/codeph ">close()</codeph> 事件并删除了引用该对象的属性和变量，只要有尚未完成操作，并且为操作的完成注册了事件处理函数，就不会将 FileStream 对象作为垃圾回收。特别是，只要以下情况之一仍然可能存在，就会永久保持未引用的 FileStream 对象： </p>
	 
	 <ul class="- topic/ul "><li class="- topic/li ">对于文件读取操作，尚未到达文件末尾（并且尚未调度 <codeph class="+ topic/ph pr-d/codeph ">complete</codeph> 事件）。 </li><li class="- topic/li ">输出数据仍然可用于写入，并且与输出有关的事件（如 <codeph class="+ topic/ph pr-d/codeph ">outputProgress</codeph> 事件或 <codeph class="+ topic/ph pr-d/codeph ">ioError</codeph> 事件）已经注册了事件侦听器。 </li></ul>
	 
	 </apiDesc><example conref="examples\FileStream.close.1.as" class="- topic/example ">     下面的代码<i class="+ topic/ph hi-d/i ">以异步方式</i> 打开 FileStream 对象并将一个名为 test.txt 的文本文件写入到用户文档目录的 Apollo Test 子目录中。调用 FileStream 对象的 <codeph class="+ topic/ph pr-d/codeph ">close()</codeph> 方法将在写入数据后关闭该文件。 
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;
import flash.events.Event;
            
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.openAsync(file, FileMode.WRITE);
fileStream.writeUTFBytes("Hello");
fileStream.addEventListener(Event.CLOSE, fileClosed);
fileStream.close();

function fileClosed(event:Event):void {
    trace("closed");
}            
</codeblock></example><example conref="examples\FileStream.close.2.as" class="- topic/example ">     下面的代码<i class="+ topic/ph hi-d/i ">以同步方式</i> 打开 FileStream 对象并将一个名为 test.txt 的文本文件写入到用户文档目录的 Apollo Test 子目录中。调用 FileStream 对象的 <codeph class="+ topic/ph pr-d/codeph ">close()</codeph> 方法将在写入数据后关闭该文件。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;
            
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.WRITE);
fileStream.writeUTF("Hello");
fileStream.close();
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/open()" class="- topic/link "><linktext class="- topic/linktext ">open()</linktext></link><link href="flash.filesystem.xml#FileStream/event:close" class="- topic/link "><linktext class="- topic/linktext ">close 事件</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:close_close" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">close</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">以异步方式打开的文件已关闭。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">以异步方式打开的文件已关闭。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:openAsync" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">openAsync</apiName><shortdesc class="- topic/shortdesc ">
	 以异步方式打开 FileStream 对象，指向由 file 参数指定的文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件位置位于应用程序目录中，并将 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数设置为“追加”、“更新”或“写入”模式。 
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">file</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.filesystem:File</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">指定要打开的文件的 File 对象。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">fileMode</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">FileMode 类中的一个字符串，用于定义 FileStream 的功能（如读取或写入文件的功能）。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 以异步方式打开 FileStream 对象，指向由 <codeph class="+ topic/ph pr-d/codeph ">file</codeph> 参数指定的文件。 
	 
	 <p class="- topic/p ">如果 FileStream 对象已打开，则调用此方法将在打开文件前关闭文件，且不会为以前打开的文件传送任何进一步事件（包括 <codeph class="+ topic/ph pr-d/codeph ">close</codeph>）。</p>
	 
	 <p class="- topic/p ">如果 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数设置为 <codeph class="+ topic/ph pr-d/codeph ">FileMode.READ</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">FileMode.UPDATE</codeph>，则文件一经打开，AIR 就会将数据读入到输入缓冲区中，并在将数据读入到输入缓冲区时调度 <codeph class="+ topic/ph pr-d/codeph ">progress</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">open</codeph> 事件。</p>
	 
	 <p class="- topic/p ">在支持文件锁定的系统中，在“写入”或“更新”模式（<codeph class="+ topic/ph pr-d/codeph ">FileMode.WRITE</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">FileMode.UPDATE</codeph>）下打开的文件在关闭前将是不可读的。</p>
	 
	 <p class="- topic/p ">对文件执行完操作后，调用 FileStream 对象的 <codeph class="+ topic/ph pr-d/codeph ">close()</codeph> 方法。某些操作系统会限制同时打开的文件数。</p>
	 
`	 </apiDesc><example conref="examples\FileStream.openAsync.1.as" class="- topic/example "> 下面的代码显示如何异步打开用户文档目录的 Apollo Test 子目录中的 test.txt 文件，然后使用系统字符集作为文本编码将该文件读入到一个字符串中。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;
import flash.events.Event;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.addEventListener(Event.COMPLETE, fileCompleteHandler)
fileStream.openAsync(file, FileMode.READ);

function fileCompleteHandler(event:Event):void {
    var str:String = fileStream.readMultiByte(fileStream.bytesAvailable, File.systemCharset);
    trace(str);
    fileStream.close();
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/close()" class="- topic/link "><linktext class="- topic/linktext ">close()</linktext></link><link href="flash.filesystem.xml#FileStream/event:complete" class="- topic/link "><linktext class="- topic/linktext ">complete 事件</linktext></link><link href="flash.filesystem.xml#FileStream/event:ioError" class="- topic/link "><linktext class="- topic/linktext ">ioError 事件</linktext></link><link href="flash.filesystem.xml#FileStream/event:progress" class="- topic/link "><linktext class="- topic/linktext ">progress 事件</linktext></link><link href="flash.filesystem.xml#FileMode" class="- topic/link "><linktext class="- topic/linktext ">FileMode</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:openAsync_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件不存在；您没有足够的权限打开该文件；您正在打开文件以进行读取访问，但您没有读取权限；或您正在打开文件以进行写入访问，但您没有写入权限。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">文件不存在；您没有足够的权限打开该文件；您正在打开文件以进行读取访问，但您没有读取权限；或您正在打开文件以进行写入访问，但您没有写入权限。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream:openAsync_progress" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">progress</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在将数据读入到输入缓冲区时调度。（必须在 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数设置为 <codeph class="+ topic/ph pr-d/codeph ">FileMode.READ</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">FileMode.UPDATE</codeph> 的情况下打开文件。）
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在将数据读入到输入缓冲区时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream:openAsync_complete" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">complete</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">已将文件数据读入到输入缓冲区。（必须在 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数设置为 <codeph class="+ topic/ph pr-d/codeph ">FileMode.READ</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">FileMode.UPDATE</codeph> 的情况下打开文件。）
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">已将文件数据读入到输入缓冲区。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:open" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">open</apiName><shortdesc class="- topic/shortdesc ">
	 以同步方式打开 FileStream 对象，指向由 file 参数指定的文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件不存在；您没有足够的权限打开该文件；您正在打开文件以进行读取访问，但您没有读取权限；或您正在打开文件以进行写入访问，但您没有写入权限。 
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件位置位于应用程序目录中，并将 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数设置为“追加”、“更新”或“写入”模式。 
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">file</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.filesystem:File</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">指定要打开的文件的 File 对象。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">fileMode</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">FileMode 类中的一个字符串，用于定义 FileStream 的功能（如读取或写入文件的功能）。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 以同步方式打开 FileStream 对象，指向由 <codeph class="+ topic/ph pr-d/codeph ">file</codeph> 参数指定的文件。 
	 
	 <p class="- topic/p ">如果 FileStream 对象已打开，则调用此方法将在打开文件前关闭文件，且不会为以前打开的文件传送任何进一步事件（包括 <codeph class="+ topic/ph pr-d/codeph ">close</codeph>）。</p>
	 
	 <p class="- topic/p ">在支持文件锁定的系统中，在“写入”或“更新”模式（<codeph class="+ topic/ph pr-d/codeph ">FileMode.WRITE</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">FileMode.UPDATE</codeph>）下打开的文件在关闭前将是不可读的。</p>
	 
	 <p class="- topic/p ">对文件执行完操作后，调用 FileStream 对象的 <codeph class="+ topic/ph pr-d/codeph ">close()</codeph> 方法。某些操作系统会限制同时打开的文件数。</p>
	 
	 </apiDesc><example conref="examples\FileStream.open.1.as" class="- topic/example "> 下面的代码显示如何同步打开用户文档目录的 Apollo Test 子目录中的 test.txt 文件，然后使用系统字符集作为文本编码将该文件读入到一个字符串中。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.READ);
var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
trace(str);
fileStream.close();
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/close()" class="- topic/link "><linktext class="- topic/linktext ">close()</linktext></link><link href="flash.filesystem.xml#File" class="- topic/link "><linktext class="- topic/linktext ">File</linktext></link><link href="flash.filesystem.xml#FileMode" class="- topic/link "><linktext class="- topic/linktext ">FileMode</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:FileStream:readBoolean" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readBoolean</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取布尔值。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个布尔值，如果字节不为零，则为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，否则为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取布尔值。读取单个字节，如果字节非零，则返回 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，否则返回 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readBoolean_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readByte" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readByte</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取带符号的字节。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">返回值的范围是从 -128 到 127。
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取带符号的字节。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readByte_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readBytes" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readBytes</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取 length 参数指定的数据字节数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">bytes</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.utils:ByteArray</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要将数据读入的 <codeph class="+ topic/ph pr-d/codeph ">ByteArray</codeph> 对象。
     </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">offset</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">0</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc "><codeph class="+ topic/ph pr-d/codeph ">bytes</codeph> 参数中的偏移，应从该位置开始读取数据。
     </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">length</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">0</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要读取的字节数。默认值 0 导致读取所有可用的数据。
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取 <codeph class="+ topic/ph pr-d/codeph ">length</codeph> 参数指定的数据字节数。将从 <codeph class="+ topic/ph pr-d/codeph ">offset</codeph> 指定的位置开始，将字节读入 <codeph class="+ topic/ph pr-d/codeph ">bytes</codeph> 参数指定的 ByteArray 对象。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readBytes_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readDouble" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readDouble</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取 IEEE 754 双精度浮点数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个 IEEE 754 双精度浮点数。
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取 IEEE 754 双精度浮点数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readDouble_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readFloat" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readFloat</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取 IEEE 754 单精度浮点数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个 IEEE 754 单精度浮点数。
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取 IEEE 754 单精度浮点数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readFloat_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readInt" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readInt</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取带符号的 32 位整数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">返回值的范围是从 -2147483648 到 2147483647。
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取带符号的 32 位整数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readInt_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readMultiByte" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readMultiByte</apiName><shortdesc class="- topic/shortdesc ">
	
     使用指定的字符集从文件流、字节流或字节数组中读取指定长度的多字节字符串。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">UTF-8 编码的字符串。
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">length</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要从字节流中读取的字节数。
     </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">charSet</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">表示用于解释字节的字符集的字符串。可能的字符集字符串包括 <codeph class="+ topic/ph pr-d/codeph ">"shift-jis"</codeph>、<codeph class="+ topic/ph pr-d/codeph ">"cn-gb"</codeph>、<codeph class="+ topic/ph pr-d/codeph ">"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html" class="- topic/xref ">支持的字符集</xref>。 
     
     <p class="- topic/p "><b class="+ topic/ph hi-d/b ">注意：</b>如果当前系统无法识别 <codeph class="+ topic/ph pr-d/codeph ">charSet</codeph> 参数的值，则 <ph class="- topic/ph ">Adobe<sup class="+ topic/ph hi-d/sup ">®</sup> Flash<sup class="+ topic/ph hi-d/sup ">®</sup> Player 或 </ph>Adobe<sup class="+ topic/ph hi-d/sup ">®</sup> AIR<sup class="+ topic/ph hi-d/sup ">®</sup> 将采用系统的默认代码页作为字符集。例如，<codeph class="+ topic/ph pr-d/codeph ">myTest.readMultiByte(22, "iso-8859-01")</codeph> 中使用 <codeph class="+ topic/ph pr-d/codeph ">01</codeph> 而不是 <codeph class="+ topic/ph pr-d/codeph ">1</codeph> 的 <codeph class="+ topic/ph pr-d/codeph ">charSet</codeph> 参数值可能在开发系统而不是另一个系统中起作用。在其他系统上，<ph class="- topic/ph ">Flash Player 或</ph> AIR 运行时将使用系统的默认代码页。</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     使用指定的字符集从文件流、字节流或字节数组中读取指定长度的多字节字符串。
     
     
     </apiDesc></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/systemCharset" class="- topic/link "><linktext class="- topic/linktext ">File.systemCharset</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:readMultiByte_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readObject" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readObject</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取以 AMF 序列化格式编码的对象。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">反序列化的对象
     
     </apiDesc><apiType value="any" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取以 AMF 序列化格式编码的对象。
     </apiDesc></apiOperationDetail><related-links class="- topic/related-links "><link href="../../flash/net/package.html#registerClassAlias()" class="- topic/link "><linktext class="- topic/linktext ">flash.net.registerClassAlias()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:readObject_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readShort" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readShort</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取带符号的 16 位整数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">返回值的范围是从 -32768 到 32767。
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取带符号的 16 位整数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readShort_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUTFBytes" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readUTFBytes</apiName><shortdesc class="- topic/shortdesc ">
	
     从字节流或字节数组中读取 UTF-8 字节序列，并返回一个字符串。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">由指定长度字符的字节表示形式生成的 UTF-8 字符串。     
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">length</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要读取的字节数。
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从字节流或字节数组中读取 UTF-8 字节序列，并返回一个字符串。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUTFBytes_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUTF" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readUTF</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取 UTF-8 字符串。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">由字符的字节表示形式生成的 UTF-8 字符串。
     
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）。
     
     <p class="- topic/p ">此方法类似于 Java<sup class="+ topic/ph hi-d/sup ">®</sup> IDataInput 接口中的 <codeph class="+ topic/ph pr-d/codeph ">readUTF()</codeph> 方法。</p>
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUTF_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedByte" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readUnsignedByte</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取无符号的字节。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">返回值的范围是从 0 到 255。        
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取无符号的字节。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedByte_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedInt" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readUnsignedInt</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取无符号的 32 位整数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">返回值的范围是从 0 到 4294967295。
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取无符号的 32 位整数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedInt_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedShort" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">readUnsignedShort</apiName><shortdesc class="- topic/shortdesc ">
	
     从文件流、字节流或字节数组中读取无符号的 16 位整数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">为读取数据而指定的位置超过了可用的字节数（由 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">EOFError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">返回值的范围是从 0 到 65535。 
     </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     从文件流、字节流或字节数组中读取无符号的 16 位整数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedShort_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:truncate" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">truncate</apiName><shortdesc class="- topic/shortdesc ">
	 在 FileStream 对象的 position 属性指定的位置截断文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件未打开，无法写入。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IllegalOperationError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 在由 FileStream 对象的 <codeph class="+ topic/ph pr-d/codeph ">position</codeph> 属性指定的位置截断文件。 
	 
	 <p class="- topic/p ">删除从 <codeph class="+ topic/ph pr-d/codeph ">position</codeph> 属性指定的位置到文件末尾之间的字节。必须打开文件以进行写入。</p>
	 
	 </apiDesc><example conref="examples\FileStream.truncate.1.as" class="- topic/example "> 下面的代码以同步方式打开用户文档目录的 Apollo Test 子目录中的 test.txt 文件，如果该文件的长度大于 100 个字符，则将其长度修剪为 100 个字符。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.UPDATE);
if (file.size > 100) {
    fileStream.position = 100;
    fileStream.truncate();
}
fileStream.close();
</codeblock></example><example conref="examples\FileStream.truncate.2.as" class="- topic/example "> 下面的代码<i class="+ topic/ph hi-d/i ">以异步方式</i>打开用户文档目录的 Apollo Test 子目录中的 test.txt 文件，如果该文件的长度大于 100 个字符，则将其长度修剪为 100 个字符。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.openAsync(file, FileMode.UPDATE);
trace("start", file.size)
if (file.size > 100) {
    fileStream.position = 100;
    fileStream.truncate();
}
fileStream.addEventListener(Event.CLOSE, fileClosed);
fileStream.close();
function fileClosed(event:Event):void {
    trace("closed", file.size); 
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/position" class="- topic/link "><linktext class="- topic/linktext ">position</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:FileStream:writeBoolean" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeBoolean</apiName><shortdesc class="- topic/shortdesc ">
	
     写入布尔值。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">确定写入哪个字节的布尔值。如果该参数为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，则写入 1；如果为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>，则写入 0。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     写入布尔值。根据 <codeph class="+ topic/ph pr-d/codeph ">value</codeph> 参数写入单个字节。如果为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，则写入 1，如果为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>，则写入 0。
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeBoolean_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeByte" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeByte</apiName><shortdesc class="- topic/shortdesc ">
	
     写入一个字节。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">int</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个整型字节值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     写入一个字节。使用了该参数的低 8 位；忽略了高 24 位。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeByte_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeBytes" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeBytes</apiName><shortdesc class="- topic/shortdesc ">
	
     在指定的字节数组 bytes 中，从 offset（使用从零开始的索引）指定的字节开始，向文件流、字节流或字节数组中写入一个长度由 length 指定的字节序列。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">bytes</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.utils:ByteArray</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要写入的字节数组。
     </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">offset</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">0</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">从零开始的索引，指定在数组中开始写入的位置。
     </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">length</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">0</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个无符号整数，指定在缓冲区中的写入范围。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     在指定的字节数组 <codeph class="+ topic/ph pr-d/codeph ">bytes</codeph> 中，从 <codeph class="+ topic/ph pr-d/codeph ">offset</codeph>（使用从零开始的索引）指定的字节开始，向文件流、字节流或字节数组中写入一个长度由 <codeph class="+ topic/ph pr-d/codeph ">length</codeph> 指定的字节序列。
     
     <p class="- topic/p ">如果省略 <codeph class="+ topic/ph pr-d/codeph ">length</codeph> 参数，则使用默认长度 0 并从 <codeph class="+ topic/ph pr-d/codeph ">offset</codeph> 开始写入整个缓冲区。如果还省略了 <codeph class="+ topic/ph pr-d/codeph ">offset</codeph> 参数，则写入整个缓冲区。 </p>
     
     <p class="- topic/p ">如果 <codeph class="+ topic/ph pr-d/codeph ">offset</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">length</codeph> 参数超出范围，它们将被锁定到 <codeph class="+ topic/ph pr-d/codeph ">bytes</codeph> 数组的开头和结尾。</p>
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeBytes_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeDouble" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeDouble</apiName><shortdesc class="- topic/shortdesc ">
	
     写入 IEEE 754 双精度（64 位）浮点数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Number</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">双精度（64 位）浮点数。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     写入 IEEE 754 双精度（64 位）浮点数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeDouble_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeFloat" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeFloat</apiName><shortdesc class="- topic/shortdesc ">
	
     写入 IEEE 754 单精度（32 位）浮点数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Number</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">单精度（32 位）浮点数。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     写入 IEEE 754 单精度（32 位）浮点数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeFloat_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeInt" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeInt</apiName><shortdesc class="- topic/shortdesc ">
	
     写入一个带符号的 32 位整数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">int</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个带符号的整型字节值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     写入一个带符号的 32 位整数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeInt_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeMultiByte" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeMultiByte</apiName><shortdesc class="- topic/shortdesc ">
	
     使用指定的字符集将多字节字符串写入文件流、字节流或字节数组中。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要写入的字符串值。
     </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">charSet</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">表示要使用的字符集的字符串。可能的字符集字符串包括 <codeph class="+ topic/ph pr-d/codeph ">"shift-jis"</codeph>、<codeph class="+ topic/ph pr-d/codeph ">"cn-gb"</codeph>、<codeph class="+ topic/ph pr-d/codeph ">"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html" class="- topic/xref ">支持的字符集</xref>。 
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     使用指定的字符集将多字节字符串写入文件流、字节流或字节数组中。 
     
     </apiDesc></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/systemCharset" class="- topic/link "><linktext class="- topic/linktext ">File.systemCharset</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:writeMultiByte_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeObject" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeObject</apiName><shortdesc class="- topic/shortdesc ">
	
     以 AMF 序列化格式将对象写入文件流、字节流或字节数组中。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">object</apiItemName><apiType value="any" name="type" class="- topic/state reference/state apiRef/apiType "/><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要进行序列化处理的对象。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     以 AMF 序列化格式将对象写入文件流、字节流或字节数组中。
     </apiDesc></apiOperationDetail><related-links class="- topic/related-links "><link href="../../flash/net/package.html#registerClassAlias()" class="- topic/link "><linktext class="- topic/linktext ">flash.net.registerClassAlias()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:writeObject_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeShort" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeShort</apiName><shortdesc class="- topic/shortdesc ">
	
     写入一个 16 位整数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">int</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个整型字节值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     写入一个 16 位整数。使用了该参数的低 16 位；忽略了高 16 位。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeShort_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUTFBytes" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeUTFBytes</apiName><shortdesc class="- topic/shortdesc ">
	
     写入一个 UTF-8 字符串。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要写入的字符串值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     写入一个 UTF-8 字符串。类似于 <codeph class="+ topic/ph pr-d/codeph ">writeUTF()</codeph>，但不使用 16 位长度的词为字符串添加前缀。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUTFBytes_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUTF" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeUTF</apiName><shortdesc class="- topic/shortdesc ">
	
     将 UTF-8 字符串写入文件流、字节流或字节数组中。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">如果字符串的长度大于 65535 个字符。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">RangeError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">RangeError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要写入的字符串值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     将 UTF-8 字符串写入文件流、字节流或字节数组中。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUTF_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUnsignedInt" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">writeUnsignedInt</apiName><shortdesc class="- topic/shortdesc ">
	
     写入一个无符号的 32 位整数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">value</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">uint</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个无符号的整型字节值。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     写入一个无符号的 32 位整数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUnsignedInt_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法）的文件调度此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.filesystem:FileStream:bytesAvailable:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">bytesAvailable</apiName><shortdesc class="- topic/shortdesc ">
	
     返回可在输入缓冲区中读取的数据的字节数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">uint</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     返回可在输入缓冲区中读取的数据的字节数。在尝试使用某一种读取方法读取数据之前，用户代码必须调用 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 以确保有足够的数据可用。
     </apiDesc><example conref="examples\FileStream.bytesAvailable.1.as" class="- topic/example "/></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:endian:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">endian</apiName><shortdesc class="- topic/shortdesc ">
	
     数据的字节顺序：为 Endian 类中的 BIG_ENDIAN 或 LITTLE_ENDIAN 常量。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="readwrite" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	
     数据的字节顺序：为 Endian 类中的 <codeph class="+ topic/ph pr-d/codeph ">BIG_ENDIAN</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">LITTLE_ENDIAN</codeph> 常量。
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:objectEncoding:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">objectEncoding</apiName><shortdesc class="- topic/shortdesc ">
     指定在使用 readObject() 或 writeObject() 方法写入或读取二进制数据时是使用 AMF3 格式还是 AMF0 格式。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="readwrite" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">uint</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
     指定在使用 <codeph class="+ topic/ph pr-d/codeph ">readObject()</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">writeObject()</codeph> 方法写入或读取二进制数据时是使用 AMF3 格式还是 AMF0 格式。
	 
	 <p class="- topic/p ">该值为 ObjectEncoding 类中的常数。在默认情况下使用 AMF3 格式。</p>
	 
	 </apiDesc></apiValueDetail><related-links class="- topic/related-links "><link href="flash.net.xml#ObjectEncoding" class="- topic/link "><linktext class="- topic/linktext ">ObjectEncoding</linktext></link><link href="flash.filesystem.xml#FileStream/readObject()" class="- topic/link "><linktext class="- topic/linktext ">readObject()</linktext></link><link href="flash.filesystem.xml#FileStream/writeObject()" class="- topic/link "><linktext class="- topic/linktext ">writeObject()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:FileStream:position:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">position</apiName><shortdesc class="- topic/shortdesc ">
	 文件中的当前位置。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="readwrite" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Number</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 文件中的当前位置。 
	 
	 <p class="- topic/p ">此值可以按以下任一方式进行修改：</p>
	 
	 <ul class="- topic/ul "><li class="- topic/li ">显式设置该属性</li><li class="- topic/li ">从 FileStream 对象中读取（通过使用一种读取方法）</li><li class="- topic/li ">写入到 FileStream 对象</li></ul>
	 
	 <p class="- topic/p ">该位置定义为一个数字（而不是单位），以支持长度大于 2<sup class="+ topic/ph hi-d/sup ">32</sup> 字节的文件。此属性的值始终是一个小于 2<sup class="+ topic/ph hi-d/sup ">53</sup> 的整数。如果将此值设置为带有小数部分的数字，则会将此值舍入到最接近的整数。</p>
	 
	 <p class="- topic/p ">在异步读取文件时，如果设置了 <codeph class="+ topic/ph pr-d/codeph ">position</codeph> 属性，应用程序将开始用从指定位置开始的数据填充读取缓冲区，而 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性可以设置为 0。在使用一种读取方法读取数据前等待 <codeph class="+ topic/ph pr-d/codeph ">complete</codeph> 事件；或在使用一种读取方法前等待 <codeph class="+ topic/ph pr-d/codeph ">progress</codeph> 事件并检查 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性。</p>
	  
	 </apiDesc><example conref="examples\FileStream.position.1.as" class="- topic/example "> 下面的代码显示应用程序从文件读取数据时，FileStream 对象的 <codeph class="+ topic/ph pr-d/codeph ">position</codeph> 属性如何更新。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.fileSystem.*;
import flash.utils.ByteArray;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory.resolvePath("Apollo Test/test.txt");
var stream:FileStream = new FileStream();
stream.addEventListener(Event.COMPLETE, readBytes);
stream.openAsync(sourceFile, FileMode.READ);

function readBytes(e:Event):void {
    var bytes:ByteArray = new ByteArray();
    trace("position 0:", stream.position); // 0
    bytes[0] = stream.readByte();
    trace("position 1:", stream.position); // 1
    fileStream.readBytes(bytes, stream.position, 4); 
    trace("position 2:", stream.position); // 5
    stream.close();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:readAhead:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">readAhead</apiName><shortdesc class="- topic/shortdesc ">
	 异步读取文件时从磁盘读取数据量的最小值。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata><asCustoms class="+ topic/metadata adobe-api-d/asCustoms "><internal>Should the readAhead value dwindle to 0 as the data is read in.
	 
	 </internal></asCustoms></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="readwrite" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Number</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 异步读取文件时从磁盘读取数据量的最小值。
	 
	 <p class="- topic/p ">此属性指定异步流在当前位置以外尝试读取的数据量。数据是基于文件系统页面大小按块读取的。因此，如果您在页面大小为 8KB（8192 字节）的计算机系统上将 <codeph class="+ topic/ph pr-d/codeph ">readAhead</codeph> 设置为 9,000，则运行时每次读取前面 2 个块，即 16384 个字节。此属性的默认值为无穷大：默认情况下，为执行异步读取而打开的文件一直读取到该文件的末尾。</p>
	 
	 <p class="- topic/p ">从读取缓冲区读取数据不会更改 <codeph class="+ topic/ph pr-d/codeph ">readAhead</codeph> 属性的值。在从缓冲区读取数据时，会读入新数据以重新填充读取缓冲区。 
	  </p>
	 
	 <p class="- topic/p "><codeph class="+ topic/ph pr-d/codeph ">readAhead</codeph> 属性对以同步方式打开的文件不起作用。</p>
	 
	 <p class="- topic/p ">由于数据是以异步方式读取的，因此 FileStream 对象将调度 <codeph class="+ topic/ph pr-d/codeph ">progress</codeph> 事件。在 <codeph class="+ topic/ph pr-d/codeph ">progress</codeph> 事件的事件处理函数方法中，查看所需的字节数是否可用（通过检查 <codeph class="+ topic/ph pr-d/codeph ">bytesAvailable</codeph> 属性），然后通过使用一种读取方法从读取缓冲区读取数据。</p>
	 
	 </apiDesc><example conref="examples\FileStream.readAhead.1.as" class="- topic/example ">     下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">readAhead</codeph> 属性将读入一个文件的数据量限制为 100 个字节：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var file:File = File.desktopDirectory.resolvePath("test.txt");
var fileStream:FileStream = new FileStream();
fileStream.readAhead = 100;
fileStream.addEventListener(ProgressEvent.PROGRESS, readProgressHandler)
fileStream.openAsync(file, FileMode.READ);
var results:ByteArray;

function readProgressHandler(event:ProgressEvent):void {
    if (fileStream.bytesAvailable >= 100) {
        fileStream.readBytes(results, 0, 100);
    }
}
</codeblock><swfblock conref="examples\FileStream.readAhead.1.swf" xml:space="preserve"/></example></apiValueDetail></apiValue></apiClassifier><apiClassifier languages="" id="flash.filesystem:FileMode" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiClassifier/apiClassifier "><apiName class="- topic/title reference/title apiRef/apiName ">FileMode</apiName><shortdesc class="- topic/shortdesc ">
 FileMode 类定义 FileStream 类的 open() 和 openAsync() 方法的 fileMode 参数中使用的字符串常量。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiClassifierDetail class="- topic/body reference/refbody apiRef/apiDetail apiClassifier/apiClassifierDetail "><apiClassifierDef class="- topic/section reference/section apiRef/apiDef apiClassifier/apiClassifierDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiBaseClassifier class="- topic/xref reference/xref apiRef/apiRelation apiClassifier/apiBaseClassifier ">Object</apiBaseClassifier></apiClassifierDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 FileMode 类定义 FileStream 类的 <codeph class="+ topic/ph pr-d/codeph ">open()</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">openAsync()</codeph> 方法的 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数中使用的字符串常量。这些方法的 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数确定文件打开后 FileStream 对象可用的功能。 
 
 <p class="- topic/p ">基于 open 方法中指定的 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数值，可以使用以下功能的多种组合：</p>
 
 <ul class="- topic/ul "><li class="- topic/li ">读取 — FileStream 对象可以从文件中读取数据。</li><li class="- topic/li ">写入 — FileStream 对象可以向文件中写入数据。</li><li class="- topic/li ">创建 — FileStream 对象可以在打开时创建不存在的文件。</li><li class="- topic/li ">打开时截断 — 打开文件时删除其中的数据（在写入任何数据之前）。</li><li class="- topic/li ">追加写入的数据 — 数据始终写入到文件的末尾（在调用任何写入方法时）。</li></ul>
 
 <p class="- topic/p ">下表显示了 FileMode 类中的每个常量在作为 FileStream 对象的 open 方法的 <codeph class="+ topic/ph pr-d/codeph ">fileMode</codeph> 参数应用时的功能：</p>
 
 <adobetable class="innertable"><tgroup cols="6" class="- topic/tgroup "><thead class="- topic/thead "><row class="- topic/row "><entry class="- topic/entry ">FileMode 常量</entry><entry align="center" class="- topic/entry ">读取</entry><entry align="center" class="- topic/entry ">编写</entry><entry align="center" class="- topic/entry ">创建</entry><entry align="center" class="- topic/entry ">打开时截断</entry><entry align="center" class="- topic/entry ">追加写入的数据</entry></row></thead><tbody class="- topic/tbody "><row class="- topic/row "><entry class="- topic/entry "><codeph class="+ topic/ph pr-d/codeph ">READ</codeph></entry><entry align="center" class="- topic/entry "> • </entry><entry class="- topic/entry "> </entry><entry class="- topic/entry "> </entry><entry class="- topic/entry "> </entry><entry class="- topic/entry "> </entry></row><row class="- topic/row "><entry class="- topic/entry "><codeph class="+ topic/ph pr-d/codeph ">WRITE</codeph></entry><entry class="- topic/entry "> </entry><entry align="center" class="- topic/entry "> • </entry><entry align="center" class="- topic/entry "> • </entry><entry align="center" class="- topic/entry "> • </entry><entry class="- topic/entry "> </entry></row><row class="- topic/row "><entry class="- topic/entry "><codeph class="+ topic/ph pr-d/codeph ">APPEND</codeph></entry><entry class="- topic/entry "> </entry><entry align="center" class="- topic/entry "> • </entry><entry align="center" class="- topic/entry "> • </entry><entry class="- topic/entry "/><entry align="center" class="- topic/entry "> • </entry></row><row class="- topic/row "><entry class="- topic/entry "><codeph class="+ topic/ph pr-d/codeph ">UPDATE</codeph></entry><entry align="center" class="- topic/entry "> • </entry><entry align="center" class="- topic/entry "> • </entry><entry align="center" class="- topic/entry "> • </entry><entry align="center" class="- topic/entry "/><entry class="- topic/entry "> </entry></row></tbody></tgroup></adobetable>
 
 </apiDesc></apiClassifierDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/open()" class="- topic/link "><linktext class="- topic/linktext ">FileStream.open()</linktext></link><link href="flash.filesystem.xml#FileStream/openAsync()" class="- topic/link "><linktext class="- topic/linktext ">FileStream.openAsync()</linktext></link></related-links><apiValue id="flash.filesystem:FileMode:APPEND" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">APPEND</apiName><shortdesc class="- topic/shortdesc "> 
	用于要在写入模式下打开的文件，并将所有写入的数据附加到文件末尾。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiData class="- topic/ph reference/ph apiRef/apiData ">append</apiData><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc "> 
	用于要在写入模式下打开的文件，并将所有写入的数据附加到文件末尾。打开文件时，会创建任何不存在的文件。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:READ" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">READ</apiName><shortdesc class="- topic/shortdesc "> 
	用于要在只读模式中打开的文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiData class="- topic/ph reference/ph apiRef/apiData ">read</apiData><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc "> 
	用于要在只读模式中打开的文件。文件必须存在（不创建缺少的文件）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:UPDATE" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">UPDATE</apiName><shortdesc class="- topic/shortdesc "> 
	用于要在读/写模式中打开的文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiData class="- topic/ph reference/ph apiRef/apiData ">update</apiData><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc "> 
	用于要在读/写模式中打开的文件。打开文件时，会创建任何不存在的文件。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:WRITE" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">WRITE</apiName><shortdesc class="- topic/shortdesc "> 
	用于要在只写模式中打开的文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiData class="- topic/ph reference/ph apiRef/apiData ">write</apiData><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc "> 
	用于要在只写模式中打开的文件。打开文件时，会创建任何不存在的文件，并截断任何现有的文件（删除其数据）。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier languages="" id="flash.filesystem:StorageVolumeInfo" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiClassifier/apiClassifier "><apiName class="- topic/title reference/title apiRef/apiName ">StorageVolumeInfo</apiName><shortdesc class="- topic/shortdesc ">
	装载或卸载存储卷时，StorageVolumeInfo 对象将调度 StorageVolumeChangeEvent 对象。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiClassifierDetail class="- topic/body reference/refbody apiRef/apiDetail apiClassifier/apiClassifierDetail "><apiClassifierDef class="- topic/section reference/section apiRef/apiDef apiClassifier/apiClassifierDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiFinal class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiFinal "/><apiBaseClassifier class="- topic/xref reference/xref apiRef/apiRelation apiClassifier/apiBaseClassifier ">flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	装载或卸载存储卷时，StorageVolumeInfo 对象将调度 StorageVolumeChangeEvent 对象。<codeph class="+ topic/ph pr-d/codeph ">StorageVolume.storageVolume</codeph> 静态属性引用调度事件的单个 singleton StorageVolumeInfo 对象。StorageVolumeInfo 类也定义 <codeph class="+ topic/ph pr-d/codeph ">getStorageVolumes</codeph> 方法，用于列出当前安装的存储卷。
	
	 <p class="- topic/p "><i class="+ topic/ph hi-d/i ">AIR 配置文件支持：</i>所有桌面操作系统均支持此功能，但所有用于电视的 AIR 设备均不支持此功能。移动设备也不支持此功能。您可以使用 <codeph class="+ topic/ph pr-d/codeph ">StorageVolumeInfo.isSupported</codeph> 属性在运行时测试是否受支持。有关在多个配置文件之间支持 API 的详细信息，请参阅 <xref href="http://help.adobe.com/en_US/air/build/WS144092a96ffef7cc16ddeea2126bb46b82f-8000.html" class="- topic/xref ">AIR 配置文件支持</xref>。</p>
	 
	<p class="- topic/p ">在现代的 Linux 发行版中，StorageVolumeInfo 对象仅对在特定位置装载的物理设备和网络驱动器调度 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeMount</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeUnmount</codeph> 事件。</p>
	
	</apiDesc><example conref="examples\StorageVolume.as" class="- topic/example "/><example conref="examples\StorageVolumeChangeEvent.as" class="- topic/example "/></apiClassifierDetail><adobeApiEvent id="flash.filesystem:StorageVolumeInfo_flash.events.StorageVolumeChangeEvent.STORAGE_VOLUME_UNMOUNT_storageVolumeUnmount" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">storageVolumeUnmount</apiName><shortdesc class="- topic/shortdesc ">
	 在已卸载存储卷后调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.StorageVolumeChangeEvent.STORAGE_VOLUME_UNMOUNT</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.StorageVolumeChangeEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 在已卸载存储卷后调度。
	 
	 <p class="- topic/p ">在现代的 Linux 发行版中，StorageVolumeInfo 对象仅对在特定位置装载的物理设备和网络驱动器调度 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeMount</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeUnmount</codeph> 事件。</p>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:StorageVolumeInfo_flash.events.StorageVolumeChangeEvent.STORAGE_VOLUME_MOUNT_storageVolumeMount" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">storageVolumeMount</apiName><shortdesc class="- topic/shortdesc ">
	 在已装载存储卷后调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.StorageVolumeChangeEvent.STORAGE_VOLUME_MOUNT</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.StorageVolumeChangeEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 在已装载存储卷后调度。
	 
	 <p class="- topic/p ">在现代的 Linux 发行版中，StorageVolumeInfo 对象仅对在特定位置装载的物理设备和网络驱动器调度 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeMount</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeUnmount</codeph> 事件。</p>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.filesystem:StorageVolumeInfo:getStorageVolumes" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">getStorageVolumes</apiName><shortdesc class="- topic/shortdesc ">
		返回与当前装载的存储卷对应的 StorageVolume 对象的矢量。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="Vector$flash.filesystem:StorageVolume" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
		返回与当前装载的存储卷对应的 StorageVolume 对象的矢量。
		
		<p class="- topic/p ">在现代的 Linux 发行版中，此方法返回与在特定位置装载的物理设备和网络驱动器对应的对象。</p>
		
		</apiDesc><example conref="examples\StorageVolume.rootDirectory.1.as" class="- topic/example "> 下列代码列出了每个装载的存储卷的根目录的本机路径：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
var volumes:Vector.&lt;StorageVolume> = new Vector.&lt;StorageVolume>;
volumes = StorageVolumeInfo.storageVolumeInfo.getStorageVolumes();
for (var i:int = 0; i &lt; volumes.length; i++)
{
    trace(volumes[i].rootDirectory.nativePath);
}
</codeblock><swfblock conref="examples\StorageVolume.rootDirectory.1.swf" xml:space="preserve"/></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#StorageVolume" class="- topic/link "><linktext class="- topic/linktext ">flash.filesystem.StorageVolume</linktext></link></related-links></apiOperation><apiValue id="flash.filesystem:StorageVolumeInfo:isSupported:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">isSupported</apiName><shortdesc class="- topic/shortdesc ">
        如果当前平台支持 StorageVolumeInfo 类，则 isSupported 属性设置为 true，否则设置为 false。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
        如果当前平台支持 StorageVolumeInfo 类，则 <codeph class="+ topic/ph pr-d/codeph ">isSupported</codeph> 属性设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，否则设置为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。 
        
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:StorageVolumeInfo:storageVolumeInfo:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">storageVolumeInfo</apiName><shortdesc class="- topic/shortdesc ">
		StorageVolumeInfo 对象的单个实例。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.filesystem:StorageVolumeInfo</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
		StorageVolumeInfo 对象的单个实例。在此对象上为 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeMount</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeUnmount</codeph> 事件注册事件侦听器。
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier languages="" id="flash.filesystem:File" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiClassifier/apiClassifier "><apiName class="- topic/title reference/title apiRef/apiName ">File</apiName><shortdesc class="- topic/shortdesc ">
 File 对象表示文件或目录的路径。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiClassifierDetail class="- topic/body reference/refbody apiRef/apiDetail apiClassifier/apiClassifierDetail "><apiClassifierDef class="- topic/section reference/section apiRef/apiDef apiClassifier/apiClassifierDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiBaseClassifier class="- topic/xref reference/xref apiRef/apiRelation apiClassifier/apiBaseClassifier ">flash.net:FileReference</apiBaseClassifier></apiClassifierDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 File 对象表示文件或目录的路径。这可以是现有的文件或目录，也可以是尚不存在的文件或目录（例如，它可以表示希望创建的文件或目录的路径）。 
 
  <p class="- topic/p ">File 类具有许多属性和方法，用于获取有关文件系统的信息和用于执行各种操作（如复制文件和目录）。</p>
  
  <p class="- topic/p ">可以与 FileStream 类一起使用 File 对象来读取和写入文件。 </p>
  
  <p class="- topic/p ">File 类扩展 FileReference 类。Flash<sup class="+ topic/ph hi-d/sup ">®</sup> Player 和 Adobe<sup class="+ topic/ph hi-d/sup ">®</sup> AIR<sup class="+ topic/ph hi-d/sup ">®</sup> 都提供了 FileReference 类，它表示指向文件的指针，但 File 类添加了一些由于安全原因，不在 Flash Player 中（在浏览器中运行的 SWF 中）公开的属性和方法。</p>
  
  <p class="- topic/p ">File 类包含一些静态属性，供引用常用目录位置。这些静态属性包括：</p>
  
  <ul class="- topic/ul "><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.applicationStorageDirectory</codeph> — 每个已安装的 AIR 应用程序独有的存储目录</li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.applicationDirectory</codeph> — 安装应用程序的只读目录（其中包括所有已安装的资源）</li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.desktopDirectory</codeph> — 用户的桌面目录</li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.documentsDirectory</codeph> — 用户的文档目录</li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.userDirectory</codeph> — 用户目录</li></ul>
  
  <p class="- topic/p ">这些属性的值在不同操作系统中均有意义。例如，在 Mac OS、Linux 和 Windows 上，用户桌面目录的本机路径各不相同。但是，<codeph class="+ topic/ph pr-d/codeph ">File.desktopDirectory</codeph> 属性在其中每个平台上，都会指向正确的桌面目录路径。要编写可以跨平台正常工作的应用程序，在需要引用应用程序使用的其他文件时，请以这些属性为基础，然后使用 <codeph class="+ topic/ph pr-d/codeph ">resolvePath()</codeph> 方法来完善路径。例如，此代码会指向应用程序存储目录中的 preferences.xml 文件：</p>
  
  <codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock "> var prefsFile:File = File.applicationStorageDirectory;
  prefsFile = prefsFile.resolvePath("preferences.xml");</codeblock>
  
  
  
  <p class="- topic/p ">如果引用文件时，使用了文本常量形式的本机路径，它将只在一个平台上有效。例如，下面的 File 对象仅在 Windows 上有效：</p> 
  
  <codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">new File("C:\Documents and Settings\joe\My Documents\test.txt")</codeblock>
  
  
  <p class="- topic/p ">应用程序存储目录非常有用。它为 AIR 应用程序提供了专用存储目录。此存储目录由 <codeph class="+ topic/ph pr-d/codeph ">File.applicationStorageDirectory</codeph> 属性定义。</p>
  
  <p class="- topic/p ">不要在应用程序目录（AIR 应用程序的安装位置）中添加或删除内容。否则会损坏 AIR 应用程序，应用程序签名也将失效。AIR 默认不允许写入应用程序目录，因为该目录并非对所有操作系统上的所有用户帐户均为可写目录。应用程序存储目录用于写入内部应用程序文件。文档目录用于写入用户希望能在应用程序之外使用的文件，如已编辑的图片或文本文件。</p>
  
  
  </apiDesc></apiClassifierDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream" class="- topic/link "><linktext class="- topic/linktext ">FileStream</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File_flash.events.FileListEvent.DIRECTORY_LISTING_directoryListing" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">directoryListing</apiName><shortdesc class="- topic/shortdesc ">
 当由于调用 getDirectoryListingAsync() 方法而提供目录列表时调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.FileListEvent.DIRECTORY_LISTING</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.FileListEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 当由于调用 <codeph class="+ topic/ph pr-d/codeph ">getDirectoryListingAsync()</codeph> 方法而提供目录列表时调度。
 
 </apiDesc></adobeApiEventDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/getDirectoryListingAsync()" class="- topic/link "><linktext class="- topic/linktext ">File.getDirectoryListingAsync()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.FileListEvent.SELECT_MULTIPLE_selectMultiple" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">selectMultiple</apiName><shortdesc class="- topic/shortdesc ">
 当用户从通过调用 browseForOpenMultiple() 方法打开的对话框中选择文件时调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.FileListEvent.SELECT_MULTIPLE</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.FileListEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 当用户从通过调用 <codeph class="+ topic/ph pr-d/codeph ">browseForOpenMultiple()</codeph> 方法打开的对话框中选择文件时调度。 
 
 
 </apiDesc></adobeApiEventDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/browseForOpenMultiple()" class="- topic/link "><linktext class="- topic/linktext ">browseForOpenMultiple()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.SELECT_select" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">select</apiName><shortdesc class="- topic/shortdesc ">
 当用户从文件浏览或目录浏览对话框中选择文件或目录时调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 当用户从文件浏览或目录浏览对话框中选择文件或目录时调度。 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">securityError</apiName><shortdesc class="- topic/shortdesc ">
 当操作违反安全限制时调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 当操作违反安全限制时调度。
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.IOErrorEvent.IO_ERROR_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><shortdesc class="- topic/shortdesc ">
 在执行异步文件操作期间发生错误时调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 在执行异步文件操作期间发生错误时调度。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.COMPLETE_complete" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">complete</apiName><shortdesc class="- topic/shortdesc ">
 在异步操作完成时调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 在异步操作完成时调度。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.CANCEL_cancel" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">cancel</apiName><shortdesc class="- topic/shortdesc ">
 在取消未处理的异步操作时调度。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><apiEventType class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiEventType ">flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
 在取消未处理的异步操作时调度。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.filesystem:File:File" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation apiOperation/apiConstructor"><apiName class="- topic/title reference/title apiRef/apiName ">File</apiName><shortdesc class="- topic/shortdesc ">
	File 类的构造函数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiConstructorDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail apiOperation/apiConstructorDetail"><apiConstructorDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiConstructorDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc "><codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数的语法无效。
	
	</apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">ArgumentError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">ArgumentError</apiOperationClassifier></apiException><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">path</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">null</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件的路径。可以通过使用 URL 或使用本机路径（特定于平台）表示法来指定路径。 
	
	<p class="- topic/p ">如果指定 URL，则可以使用以下 URL 架构之一：<codeph class="+ topic/ph pr-d/codeph ">file</codeph>、<codeph class="+ topic/ph pr-d/codeph ">app</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">app-storage</codeph>。下面是使用 URL 表示法时 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数的有效值： </p>
	
	<ul class="- topic/ul "><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">“app:/DesktopPathTest.xml”</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">“app-storage:/preferences.xml”</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">“file:///C:/Documents%20and%20Settings/bob/Desktop”</codeph>（Bob 的 Windows 计算机桌面）</li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">“file:///Users/bob/Desktop”</codeph>（Bob 的 Mac 计算机桌面）</li></ul>
	
	<p class="- topic/p "><codeph class="+ topic/ph pr-d/codeph ">app</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">app-storage</codeph> URL 方案很有用，因为这些方案在所有文件系统中均可指向有效的文件。不过，在另外两个使用 <codeph class="+ topic/ph pr-d/codeph ">file</codeph> URL 架构指向用户桌面目录的示例中，最好是<i class="+ topic/ph hi-d/i ">不</i> 将 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数传递给 <codeph class="+ topic/ph pr-d/codeph ">File()</codeph> 构造函数，然后将 <codeph class="+ topic/ph pr-d/codeph ">File.desktopDirectory</codeph> 分配给 File 对象，以此作为访问独立于平台和独立于用户的桌面目录的方式。</p>
	
	<p class="- topic/p ">如果指定本机路径，则在 Windows 中可以使用反斜杠字符或正斜杠字符作为此参数中的路径分隔符；在 Mac OS 和 Linux 中则使用正斜杠字符。下面是使用本机路径表示法时 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数的有效值：</p>
	
	<ul class="- topic/ul "><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">“C:/Documents and Settings/bob/Desktop”</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">“/Users/bob/Desktop”</codeph></li></ul>
	
	<p class="- topic/p ">不过，对于这两个示例，<i class="+ topic/ph hi-d/i ">不应</i> 将 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数传递给 <codeph class="+ topic/ph pr-d/codeph ">File()</codeph> 构造函数，然后将 <codeph class="+ topic/ph pr-d/codeph ">File.desktopDirectory</codeph> 分配给 File 对象，以此作为访问独立于平台和独立于用户的桌面目录的方式。</p>
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	File 类的构造函数。 
	
	<p class="- topic/p ">如果传递 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数，File 对象将指向指定的路径，并将设置 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 属性和 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性以反映该路径。</p>
	
	
	<p class="- topic/p ">尽管可以传递 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数来指定文件路径，但请考虑这是否会生成平台专用代码。例如，这样的本机路径 <codeph class="+ topic/ph pr-d/codeph ">"C:\\Documents and Settings\\bob\\Desktop"</codeph>，或这样的 URL <codeph class="+ topic/ph pr-d/codeph ">"file:///C:/Documents%20and%20Settings/bob/Desktop"</codeph> 仅在 Windows 上有效。较好的方法是使用以下这些静态属性，它们可以表示常用目录，且在所有平台上均有效：</p>
	
	<ul class="- topic/ul "><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.applicationDirectory</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.applicationStorageDirectory</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.desktopDirectory</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.documentsDirectory</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.userDirectory</codeph></li></ul>
	
	<p class="- topic/p ">然后可以使用 <codeph class="+ topic/ph pr-d/codeph ">resolvePath()</codeph> 方法来获取这些目录的相对路径。例如，以下代码可以设置 File 对象，使其指向应用程序存储目录中的 settings.xml 文件：</p>
	
	<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">var file:File = File.applicationStorageDirectory.resolvePath("settings.xml");</codeblock>
	
	
	
	<p class="- topic/p "><b class="+ topic/ph hi-d/b ">重要：</b>如果在 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数中传递 URL 字符串，将解码 URL 以解析文件路径。例如，语句 <codeph class="+ topic/ph pr-d/codeph ">new File("file:///c:/test/demo%20file%201%2e0.txt")</codeph> 使用本机路径“c:\test\demo file 1.0.txt”创建一个 File 对象。（使用 file:、app: 或 app-storage: 方案前缀的 URL。）然而，如果省略了有效的 URL 前缀，则路径字符串将被作为本机路径处理，不会发生解码操作。在验证来自可能不受信任的源的路径时，必须考虑这种行为。如果仅验证输入字符串，URL 解码操作可能会让攻击者绕过您的验证检查。请始终验证实例化 File 对象的最终路径：</p>
	 
	 <codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
	 var file:File = new File( taintedString );
	 validate( file.nativePath ); //where validate() is your path validation function
	 </codeblock> 
	  
	 
	</apiDesc></apiConstructorDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/nativePath" class="- topic/link "><linktext class="- topic/linktext ">nativePath</linktext></link></related-links></apiConstructor><apiOperation id="flash.filesystem:File:browseForDirectory" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">browseForDirectory</apiName><shortdesc class="- topic/shortdesc ">
	 显示一个目录选择器对话框，用户可从中选择一个目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">当前正在运行浏览操作（browseForOpen()、browseForOpenMultiple()、browseForSave()、browseForDirectory()）。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IllegalOperationError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">title</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">显示在对话框标题栏中的字符串。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 显示一个目录选择器对话框，用户可从中选择一个目录。当用户选择该目录时，将调度 <codeph class="+ topic/ph pr-d/codeph ">select</codeph> 事件。<codeph class="+ topic/ph pr-d/codeph ">select</codeph> 事件的 <codeph class="+ topic/ph pr-d/codeph ">target</codeph> 属性是指向所选目录的 File 对象。
	 
	 <p class="- topic/p ">目录选择器对话框并不始终显示在由另一个窗口（具有非空 <codeph class="+ topic/ph pr-d/codeph ">owner</codeph> 属性的窗口）拥有的窗口的前面。 要避免窗口顺序问题，请在调用此方法之前隐藏所拥有的窗口。</p>
	 
	 <p class="- topic/p "><b class="+ topic/ph hi-d/b ">注意：</b>在 Android 设备上，不支持 <codeph class="+ topic/ph pr-d/codeph ">browseForDirectory()</codeph>。File 对象立即调度 cancel 事件。</p>
	 
	 </apiDesc><example conref="examples\File.browseForDirectory.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">File.browseForDirectory()</codeph> 方法让用户选择一个目录。当选择目录时，此代码会在 <codeph class="+ topic/ph pr-d/codeph ">trace()</codeph> 输出中列出所选目录的内容。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
import flash.events.Event;

var directory:File = File.documentsDirectory;

try
{
    directory.browseForDirectory("Select Directory");
    directory.addEventListener(Event.SELECT, directorySelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function directorySelected(event:Event):void 
{
    directory = event.target as File;
    var files:Array = directory.getDirectoryListing();
    for(var i:uint = 0; i &lt; files.length; i++)
    {
        trace(files[i].name);
    }
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/browseForOpen()" class="- topic/link "><linktext class="- topic/linktext ">browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/browseForSave()" class="- topic/link "><linktext class="- topic/linktext ">browseForSave()</linktext></link><link href="flash.filesystem.xml#File/event:select" class="- topic/link "><linktext class="- topic/linktext ">select</linktext></link><link href="flash.net.xml#FileFilter" class="- topic/link "><linktext class="- topic/linktext ">flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForDirectory_cancel" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">cancel</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在用户单击“打开文件”对话框中的“取消”按钮时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在用户单击“打开文件”对话框中的“取消”按钮时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForDirectory_select" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">select</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在用户选择目录并关闭目录选择器对话框时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在用户选择目录并关闭目录选择器对话框时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForDirectory_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在此平台上不支持浏览操作。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在此平台上不支持浏览操作。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForOpenMultiple" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">browseForOpenMultiple</apiName><shortdesc class="- topic/shortdesc ">
	 显示“打开文件”对话框，用户可从中选择一个或多个要打开的文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">当前正在运行浏览操作（browseForOpen()、browseForOpenMultiple()、browseForSave()、browseForDirectory()）。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IllegalOperationError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">title</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">显示在对话框标题栏中的字符串。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">typeFilter</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Array</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">null</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个 FileFilter 实例数组，用于过滤在对话框中显示的文件。如果省略此参数，则显示所有文件。有关详细信息，请参阅 FileFilter 类。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 显示“打开文件”对话框，用户可从中选择一个或多个要打开的文件。
	 
	 <p class="- topic/p ">当用户选择文件时，将调度 <codeph class="+ topic/ph pr-d/codeph ">selectMultiple</codeph> 事件。<codeph class="+ topic/ph pr-d/codeph ">select</codeph> 事件的 <codeph class="+ topic/ph pr-d/codeph ">target</codeph> 属性是此 File 对象。与 <codeph class="+ topic/ph pr-d/codeph ">browseForOpen()</codeph> 不同，使用 <codeph class="+ topic/ph pr-d/codeph ">browseForOpenMultiple()</codeph> 方法时，此 File 对象不会更新以引用任何所选的文件。相反，生成的 <codeph class="+ topic/ph pr-d/codeph ">selectMultiple</codeph> 事件包含所选文件的数组。</p>
	 
	 <p class="- topic/p ">“打开文件”对话框并不始终显示在由另一个窗口（具有非空 <codeph class="+ topic/ph pr-d/codeph ">owner</codeph> 属性的窗口）拥有的窗口的前面。 要避免窗口顺序问题，请在调用此方法之前隐藏所拥有的窗口。</p>
	 
	 <p class="- topic/p "><b class="+ topic/ph hi-d/b ">注意：</b>在 Android 设备上，无法设置文件对话框标题。忽略 <codeph class="+ topic/ph pr-d/codeph ">title</codeph> 参数。</p>
	 
	 </apiDesc><example conref="examples\File.browseForOpenMultiple.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">File.browseForOpenMultiple()</codeph> 方法让用户选择多个文件。当选择多个文件时，此代码输出所选文件的路径。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;
import flash.events.FileListEvent;

var docsDir:File = File.documentsDirectory;
try
{
    docsDir.browseForOpenMultiple("Select Files");
    docsDir.addEventListener(FileListEvent.SELECT_MULTIPLE, filesSelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function filesSelected(event:FileListEvent):void 
{
    for (var i:uint = 0; i &lt; event.files.length; i++) 
    {
        trace(event.files[i].nativePath);
    }
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/browseForSave()" class="- topic/link "><linktext class="- topic/linktext ">browseForSave()</linktext></link><link href="flash.filesystem.xml#File/browseForOpen()" class="- topic/link "><linktext class="- topic/linktext ">browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/browseForDirectory()" class="- topic/link "><linktext class="- topic/linktext ">browseForDirectory()</linktext></link><link href="flash.filesystem.xml#File/event:selectMultiple" class="- topic/link "><linktext class="- topic/linktext ">selectMultiple</linktext></link><link href="flash.net.xml#FileFilter" class="- topic/link "><linktext class="- topic/linktext ">flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_cancel" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">cancel</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在用户单击“打开文件”对话框中的“取消”按钮时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在用户单击“打开文件”对话框中的“取消”按钮时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_selectMultiple" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">selectMultiple</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:FileListEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在用户选择文件并关闭“打开文件”对话框时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在用户选择文件并关闭“打开文件”对话框时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在此平台上不支持浏览操作。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在此平台上不支持浏览操作。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForOpen" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">browseForOpen</apiName><shortdesc class="- topic/shortdesc ">
	 显示“打开文件”对话框，用户可从中选择要打开的文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">当前正在运行浏览操作（browseForOpen()、browseForOpenMultiple()、browseForSave()、browseForDirectory()）。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IllegalOperationError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">title</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">显示在对话框标题栏中的字符串。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">typeFilter</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Array</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">null</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">一个 FileFilter 实例数组，用于过滤在对话框中显示的文件。如果省略此参数，则显示所有文件。有关详细信息，请参阅 FileFilter 类。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 显示“打开文件”对话框，用户可从中选择要打开的文件。
	 
	 <p class="- topic/p ">当用户选择该文件时，将调度 <codeph class="+ topic/ph pr-d/codeph ">select</codeph> 事件。<codeph class="+ topic/ph pr-d/codeph ">select</codeph> 事件的 <codeph class="+ topic/ph pr-d/codeph ">target</codeph> 属性是指向所选文件的 File 对象。</p>
	 
	 <p class="- topic/p ">“打开文件”对话框并不始终显示在由另一个窗口（具有非空 <codeph class="+ topic/ph pr-d/codeph ">owner</codeph> 属性的窗口）拥有的窗口的前面。 要避免窗口顺序问题，请在调用此方法之前隐藏所拥有的窗口。</p>
	 
	 <p class="- topic/p "><b class="+ topic/ph hi-d/b ">注意：</b>在 Android 设备上，无法设置文件对话框标题。忽略 <codeph class="+ topic/ph pr-d/codeph ">title</codeph> 参数。</p>
	 
	 </apiDesc><example conref="examples\File.browseForOpen.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">File.browseForOpen()</codeph> 方法让用户选择一个文本文件。当选择此文件时，此代码将文件数据读入到字符串中。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;
import flash.events.Event;
import flash.net.FileFilter;

var fileToOpen:File = new File();
var txtFilter:FileFilter = new FileFilter("Text", "*.as;*.css;*.html;*.txt;*.xml");

try 
{
    fileToOpen.browseForOpen("Open", [txtFilter]);
    fileToOpen.addEventListener(Event.SELECT, fileSelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function fileSelected(event:Event):void 
{
    var stream:FileStream = new FileStream();
    stream.open(event.target, FileMode.READ);
    var fileData:String = stream.readUTFBytes(stream.bytesAvailable);
    trace(fileData);
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/browseForSave()" class="- topic/link "><linktext class="- topic/linktext ">browseForSave()</linktext></link><link href="flash.filesystem.xml#File/browseForOpenMultiple()" class="- topic/link "><linktext class="- topic/linktext ">browseForOpenMultiple()</linktext></link><link href="flash.filesystem.xml#File/browseForDirectory()" class="- topic/link "><linktext class="- topic/linktext ">browseForDirectory()</linktext></link><link href="flash.filesystem.xml#File/event:select" class="- topic/link "><linktext class="- topic/linktext ">select</linktext></link><link href="flash.net.xml#FileFilter" class="- topic/link "><linktext class="- topic/linktext ">flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForOpen_cancel" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">cancel</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在用户单击“打开文件”对话框中的“取消”按钮时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在用户单击“打开文件”对话框中的“取消”按钮时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpen_select" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">select</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在用户选择文件并关闭“打开文件”对话框时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在用户选择文件并关闭“打开文件”对话框时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpen_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在此平台上不支持浏览操作。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在此平台上不支持浏览操作。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForSave" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">browseForSave</apiName><shortdesc class="- topic/shortdesc ">
	 显示“保存文件”对话框，用户可从中选择一个文件目标。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">当前正在运行浏览操作（browseForOpen()、browseForOpenMultiple()、browseForSave()、browseForDirectory()）。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IllegalOperationError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">title</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">显示在对话框标题栏中的字符串。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 显示“保存文件”对话框，用户可从中选择一个文件目标。 
	 
	 <p class="- topic/p ">当用户选择该文件时，将调度 <codeph class="+ topic/ph pr-d/codeph ">select</codeph> 事件。<codeph class="+ topic/ph pr-d/codeph ">select</codeph> 事件的 <codeph class="+ topic/ph pr-d/codeph ">target</codeph> 属性是指向所选保存目标的 File 对象。</p>
	 
	 <p class="- topic/p ">“保存文件”对话框并不始终显示在由另一个窗口（具有非空 <codeph class="+ topic/ph pr-d/codeph ">owner</codeph> 属性的窗口）拥有的窗口的前面。 要避免窗口顺序问题，请在调用此方法之前隐藏所拥有的窗口。</p>
	 
	 <p class="- topic/p "><b class="+ topic/ph hi-d/b ">注意：</b>在 Android 设备上，无法设置文件对话框标题。忽略 <codeph class="+ topic/ph pr-d/codeph ">title</codeph> 参数。</p>
	 
	 </apiDesc><example conref="examples\File.browseForSave.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">File.browseForSave()</codeph> 方法让用户选择用于保存文件的路径。在选择文件时，此代码将数据保存到所选的文件路径。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;
import flash.events.Event;

var docsDir:File = File.documentsDirectory;
try
{
    docsDir.browseForSave("Save As");
    docsDir.addEventListener(Event.SELECT, saveData);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function saveData(event:Event):void 
{
    var newFile:File = event.target as File;
    var str:String = "Hello.";
    if (!newFile.exists)
    {
        var stream:FileStream = new FileStream();
        stream.open(newFile, FileMode.WRITE);
        stream.writeUTFBytes(str);
        stream.close();
    }
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/browseForDirectory()" class="- topic/link "><linktext class="- topic/linktext ">browseForDirectory()</linktext></link><link href="flash.filesystem.xml#File/browseForOpen()" class="- topic/link "><linktext class="- topic/linktext ">browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/event:select" class="- topic/link "><linktext class="- topic/linktext ">select</linktext></link><link href="flash.net.xml#FileFilter" class="- topic/link "><linktext class="- topic/linktext ">flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForSave_cancel" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">cancel</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在用户单击“保存文件”对话框中的“取消”按钮时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在用户单击“保存文件”对话框中的“取消”按钮时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForSave_select" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">select</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在用户选择文件并关闭“保存文件”对话框时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在用户选择文件并关闭“保存文件”对话框时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForSave_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在此平台上不支持浏览操作。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在此平台上不支持浏览操作。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:cancel" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">cancel</apiName><shortdesc class="- topic/shortdesc ">
	 取消任何未处理的异步操作。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiIsOverride class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiIsOverride "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 取消任何未处理的异步操作。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:canonicalize" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">canonicalize</apiName><shortdesc class="- topic/shortdesc ">
	 规范化 File 路径。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 规范化 File 路径。
	 
	 <p class="- topic/p ">如果 File 对象表示现有的文件或目录，规范化将调整该路径，使其与实际文件名或目录名的大小写相匹配。如果 File 对象是符号链接，规范化将调整该路径，使其与该链接所指向的文件或目录相匹配，不管所指向的文件或目录是否存在。在区分大小写的文件系统（如 Linux）上，当多个文件的名称只有大小写不同时，<codeph class="+ topic/ph pr-d/codeph ">canonicalize()</codeph> 方法将调整路径以匹配最先找到的文件（以文件系统确定的顺序）。</p>
	 
	 <p class="- topic/p ">此外，在 Windows 中，规范化会将短文件名转换成长文件名。</p>
	 
	 </apiDesc><example conref="examples\File.canonicalize.2.as" class="- topic/example ">     下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">canonicalize()</codeph> 方法查找目录名的正确大小写。运行此示例前，在您的计算机桌面上创建一个名为 AIR Test 的目录。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var path:File = File.desktopDirectory.resolvePath("air test");
trace(path.nativePath); 
path.canonicalize();
trace(path.nativePath); // ...\AIR Test

</codeblock></example><example conref="examples\File.canonicalize.1.as" class="- topic/example ">     下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">canonicalize()</codeph> 方法基于 Windows 目录的短名称查找其长名称。此示例假定在 C: 驱动器的根目录中有一个 AIR Test 目录，并且系统已将短名称 AIR~1 分配给该目录。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var path:File = new File();
path.nativePath = "C:\\AIR~1";
path.canonicalize();
trace(path.nativePath); // C:\AIR Test
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:clone" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">clone</apiName><shortdesc class="- topic/shortdesc ">
	 返回此 File 对象的副本。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 返回此 File 对象的副本。未复制事件注册。
	 
	 <p class="- topic/p "><i class="+ topic/ph hi-d/i ">注意：</i>此方法<i class="+ topic/ph hi-d/i ">不</i> 复制文件本身。它仅制作 <ph class="- topic/ph ">ActionScript</ph> File 对象实例的副本。要复制文件，请使用 <codeph class="+ topic/ph pr-d/codeph ">copyTo()</codeph> 方法。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:copyToAsync" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">copyToAsync</apiName><shortdesc class="- topic/shortdesc ">
	 开始将此 File 对象指定的位置中的文件或目录复制到 destination 参数指定的位置。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有向目标写入的必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">newLocation</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.net:FileReference</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">新文件的目标位置。请注意，此 File 对象指定生成（复制）的文件或目录，<i class="+ topic/ph hi-d/i ">不是</i> 包含该文件或目录的目录的路径。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">overwrite</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">false</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">如果为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>，则当由 <codeph class="+ topic/ph pr-d/codeph ">target</codeph> 文件指定的文件已经存在时复制将失败。如果为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，则该操作将覆盖任何现有的同名文件或目录。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 开始将此 File 对象指定的位置中的文件或目录复制到 <codeph class="+ topic/ph pr-d/codeph ">destination</codeph> 参数指定的位置。 
	 
	 <p class="- topic/p ">完成后，将调度 <codeph class="+ topic/ph pr-d/codeph ">complete</codeph> 事件（成功）或 <codeph class="+ topic/ph pr-d/codeph ">ioError</codeph> 事件（失败）。复制过程将创建任何需要的父目录（如有可能）。</p>
	 
	 </apiDesc><example conref="examples\File.copyToAsync.1.as" class="- topic/example "> 下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">copyToAsync()</codeph> 方法复制文件。在运行此代码之前，请确保在计算机上文档目录的 AIR Test 子目录中创建一个 test1.txt 文件。生成的复制文件名为 test2.txt，并且也在 AIR Test 子目录中。将 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 参数设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph> 时，此操作将覆盖任何现有的 test2.txt 文件。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

sourceFile.copyToAsync(destination, true);
sourceFile.addEventListener(Event.COMPLETE, fileCopiedHandler);

function fileCopiedHandler(event:Event):void {
    trace("Done.");
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/copyTo()" class="- topic/link "><linktext class="- topic/linktext ">copyTo()</linktext></link><link href="flash.filesystem.xml#File/moveToAsync()" class="- topic/link "><linktext class="- topic/linktext ">moveToAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:copyToAsync_complete" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">complete</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在文件或目录已成功复制时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在文件或目录已成功复制时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:copyToAsync_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">源不存在；或者目标存在且 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>；或者无法将源复制到目标；或者源和目标引用相同的文件或文件夹且 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>。在 Windows 中无法复制打开的文件，也无法复制包含已打开文件的目录。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">源不存在；或目标存在但 overwrite 为 false；或无法将源复制到目标；或源和目标引用相同的文件或文件夹但 overwrite 设置为 true。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:copyTo" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">copyTo</apiName><shortdesc class="- topic/shortdesc ">
	 将由此 File 对象指定的位置的文件或目录复制到由 newLocation 参数指定的位置。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">源不存在；或者目标存在且 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>；或者无法将源复制到目标；或者源和目标引用相同的文件或文件夹且 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>。在 Windows 中无法复制打开的文件，也无法复制包含已打开文件的目录。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有向目标写入的必要权限。
	  
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">newLocation</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.net:FileReference</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">新文件的目标位置。请注意，此 File 对象指定生成（复制）的文件或目录，<i class="+ topic/ph hi-d/i ">不是</i> 包含该文件或目录的目录的路径。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">overwrite</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">false</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">如果为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>，则当由 <codeph class="+ topic/ph pr-d/codeph ">target</codeph> 参数指定的文件已经存在时复制将失败。如果为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，该操作将覆盖现有的同名文件或目录。  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 将由此 File 对象指定的位置的文件或目录复制到由 <codeph class="+ topic/ph pr-d/codeph ">newLocation</codeph> 参数指定的位置。复制过程将创建任何需要的父目录（如有可能）。
	 
	 </apiDesc><example conref="examples\File.copyTo.1.as" class="- topic/example "> 下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">copyTo()</codeph> 方法复制文件。运行此代码之前，请在计算机上文档目录的 AIR Test 子目录中创建一个 test1.txt 文件。生成的复制文件名为 test2.txt，并且也在 AIR Test 子目录中。将 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 参数设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph> 时，此操作将覆盖任何现有的 test2.txt 文件。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:FileReference = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:FileReference = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

if (sourceFile.copyTo(destination, true)) {
    trace("Done.");
}
</codeblock></example><example conref="examples\File.copyTo.2.as" class="- topic/example "> 下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">copyTo()</codeph> 方法复制文件。运行此代码之前，在计算机上主目录的 AIR Test 子目录中创建一个 test1.txt 文件。生成的复制文件名为 test2.txt。<codeph class="+ topic/ph pr-d/codeph ">try</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">catch</codeph> 语句显示如何响应错误。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

try 
{
    sourceFile.copyTo(destination, true);
}
catch (error:Error)
{
    trace("Error:", error.message);
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/copyToAsync()" class="- topic/link "><linktext class="- topic/linktext ">copyToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveTo()" class="- topic/link "><linktext class="- topic/linktext ">moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:createDirectory" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">createDirectory</apiName><shortdesc class="- topic/shortdesc ">
	 创建指定的目录和任何所需的父目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">目录不存在且无法创建。 
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 创建指定的目录和任何所需的父目录。如果该目录已存在，则不执行任何操作。
	 
	 </apiDesc><example conref="examples\File.createDirectory.1.as" class="- topic/example ">     下面的代码将桌面上名为 test.txt 的文件移动到文档目录的 AIR Test 子目录中。调用 <codeph class="+ topic/ph pr-d/codeph ">createDirectory()</codeph> 方法以确保 AIR Test 目录存在后才移动此文件。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var source:File = File.desktopDirectory.resolvePath("test.txt");
var target:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var targetParent:File = target.parent;
targetParent.createDirectory();
source.moveTo(target, true);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:createTempDirectory" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">createTempDirectory</apiName><shortdesc class="- topic/shortdesc ">
	 返回对新临时目录的引用。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">引用新临时目录的 File 对象。
	 
	 </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 返回对新临时目录的引用。这是一个位于系统临时目录路径中的新目录。
	 
	 <p class="- topic/p ">使用此方法来标识新的唯一目录，无需查询系统即可以确定该目录是新的唯一目录。</p>
	 
	 <p class="- topic/p ">您可能需要在关闭应用程序前删除该临时目录，因为在某些设备上它不会自动删除。</p>
	 
	 </apiDesc><example conref="examples\File.createTempDirectory.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">createTempFile()</codeph> 方法获取对新临时目录的引用。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.File;

var temp:File = File.createTempDirectory();
trace(temp.nativePath);
</codeblock> 每次运行此代码时都会创建一个新的（唯一的）文件。 
</example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/createTempFile()" class="- topic/link "><linktext class="- topic/linktext ">createTempFile()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:createTempFile" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">createTempFile</apiName><shortdesc class="- topic/shortdesc ">
	 返回对新临时文件的引用。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">引用新临时文件的 File 对象。
	 
	 </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 返回对新临时文件的引用。这是一个位于系统临时目录路径中的新文件。
	 
	 <p class="- topic/p ">使用此方法来标识新的唯一文件，无需查询系统即可以确定该文件是新的唯一文件。</p>
	 
	 <p class="- topic/p ">您可能需要在关闭应用程序前删除该临时文件，因为它不会自动删除。</p>
	 
	 </apiDesc><example conref="examples\File.createTempFile.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">createTempFile()</codeph> 方法获取对新临时文件的引用。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.File;

var temp:File = File.createTempFile();
trace(temp.nativePath);
</codeblock> 每次运行此代码时都会创建一个新的（唯一的）文件。 
</example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/createTempDirectory()" class="- topic/link "><linktext class="- topic/linktext ">createTempDirectory()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteDirectoryAsync" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">deleteDirectoryAsync</apiName><shortdesc class="- topic/shortdesc ">
	 异步删除目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有删除目录的必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">deleteDirectoryContents</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">false</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">指定是否删除包含文件或子目录的目录。如果为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>，则当该目录包含文件或目录时，File 对象将调度 <codeph class="+ topic/ph pr-d/codeph ">ioError</codeph> 事件。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 异步删除目录。如果此 File 实际上是指向目录的符号链接，则删除的是链接，而非目录。
	 
	 </apiDesc></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/deleteDirectory()" class="- topic/link "><linktext class="- topic/linktext ">deleteDirectory()</linktext></link><link href="flash.filesystem.xml#File/deleteFileAsync()" class="- topic/link "><linktext class="- topic/linktext ">deleteFileAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()" class="- topic/link "><linktext class="- topic/linktext ">moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:deleteDirectoryAsync_complete" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">complete</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在目录已成功删除时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在目录已成功删除时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:deleteDirectoryAsync_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">目录不存在或无法删除。在 Windows 中无法删除包含已打开文件的目录。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">目录不存在或无法删除。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:deleteDirectory" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">deleteDirectory</apiName><shortdesc class="- topic/shortdesc ">
	 删除目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">目录不存在或无法删除。在 Windows 中无法删除包含已打开文件的目录。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有删除目录的必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">deleteDirectoryContents</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">false</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">指定是否删除包含文件或子目录的目录。如果为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>，则当该目录包含文件或目录时，调用此方法将引发异常。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 删除目录。如果此 File 实际上是指向目录的符号链接，则删除的是链接，而非目录。
	 
	 </apiDesc><example conref="examples\File.deleteDirectory.1.as" class="- topic/example "> 下面的代码创建一个空目录，然后使用 <codeph class="+ topic/ph pr-d/codeph ">deleteDirectory()</codeph> 方法删除该目录。 
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var directory:File = File.documentsDirectory.resolvePath("Empty Junk Directory/");
File.createDirectory(directory);
trace(directory.exists); // true
directory.deleteDirectory();
trace(directory.exists); // false
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/deleteDirectoryAsync()" class="- topic/link "><linktext class="- topic/linktext ">deleteDirectoryAsync()</linktext></link><link href="flash.filesystem.xml#File/deleteFile()" class="- topic/link "><linktext class="- topic/linktext ">deleteFile()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()" class="- topic/link "><linktext class="- topic/linktext ">moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteFileAsync" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">deleteFileAsync</apiName><shortdesc class="- topic/shortdesc ">
	 异步删除文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有删除文件的必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 异步删除文件。如果此 File 实际上是符号链接，则删除的是链接，而非目标文件。
	 
	 </apiDesc></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/deleteDirectoryAsync()" class="- topic/link "><linktext class="- topic/linktext ">deleteDirectoryAsync()</linktext></link><link href="flash.filesystem.xml#File/deleteFile()" class="- topic/link "><linktext class="- topic/linktext ">deleteFile()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()" class="- topic/link "><linktext class="- topic/linktext ">moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:deleteFileAsync_complete" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">complete</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在文件已成功删除时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在文件已成功删除时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:deleteFileAsync_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件不存在或无法删除。在 Windows 中无法删除当前打开的文件。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">文件不存在或无法删除。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:deleteFile" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">deleteFile</apiName><shortdesc class="- topic/shortdesc ">
	 删除文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件不存在或无法删除。在 Windows 中无法删除当前打开的文件。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有删除文件的必要权限。

	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 删除文件。如果此 File 实际上是符号链接，则删除的是链接，而非目标文件。
	 
	 </apiDesc><example conref="examples\File.deleteFile.1.as" class="- topic/example "> 下面的代码创建一个临时文件，然后调用 <codeph class="+ topic/ph pr-d/codeph ">deleteFile()</codeph> 方法以删除该文件。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var file:File = File.createTempFile();
trace(file.exists); // true
file.deleteFile();
trace(file.exists); // false
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/deleteDirectory()" class="- topic/link "><linktext class="- topic/linktext ">deleteDirectory()</linktext></link><link href="flash.filesystem.xml#File/deleteFileAsync()" class="- topic/link "><linktext class="- topic/linktext ">deleteFileAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()" class="- topic/link "><linktext class="- topic/linktext ">moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:getDirectoryListingAsync" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">getDirectoryListingAsync</apiName><shortdesc class="- topic/shortdesc ">
	 异步检索与此 File 对象表示的目录内容对应的 File 对象的数组。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 异步检索与此 File 对象表示的目录内容对应的 File 对象的数组。 
	 
	 </apiDesc><example conref="examples\File.getDirectoryListingAsync.1.as" class="- topic/example "> 下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">getDirectoryListingAsync()</codeph> 方法枚举用户目录的内容。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
import flash.events.FileListEvent;

var directory:File = File.userDirectory;
directory.getDirectoryListingAsync();
directory.addEventListener(FileListEvent.DIRECTORY_LISTING, directoryListingHandler);

function directoryListingHandler(event:FileListEvent):void {
    var list:Array = event.files;
    for (var i:uint = 0; i &lt; list.length; i++) {
        trace(list[i].nativePath);
    }
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/getDirectoryListing()" class="- topic/link "><linktext class="- topic/linktext ">getDirectoryListing()</linktext></link><link href="flash.filesystem.xml#File/getRootDirectories()" class="- topic/link "><linktext class="- topic/linktext ">getRootDirectories()</linktext></link><link href="flash.filesystem.xml#File/event:directoryListing" class="- topic/link "><linktext class="- topic/linktext ">directoryListing 事件</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:getDirectoryListingAsync_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">您没有足够的权限读取此目录，或此目录不存在。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">您没有足够的权限读取此目录，或此目录不存在。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:getDirectoryListingAsync_directoryListing" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">directoryListing</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:FileListEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">目录内容已成功枚举。<codeph class="+ topic/ph pr-d/codeph ">contents</codeph> 事件具有一个 <codeph class="+ topic/ph pr-d/codeph ">files</codeph> 属性，该属性是生成的 File 对象数组。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">目录内容已成功枚举。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:getDirectoryListing" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">getDirectoryListing</apiName><shortdesc class="- topic/shortdesc ">
	 返回与此 File 对象表示的目录中的文件和目录对应的 File 对象的数组。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">File 对象的数组。
	 
	 </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 返回与此 File 对象表示的目录中的文件和目录对应的 File 对象的数组。此方法不浏览子目录的内容。
	 
	 </apiDesc><example conref="examples\File.getDirectoryListing.1.as" class="- topic/example "> 下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">getDirectoryListing()</codeph> 方法枚举用户目录的内容。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var directory:File = File.userDirectory;
var list:Array = directory.getDirectoryListing();
for (var i:uint = 0; i &lt; list.length; i++) {
    trace(list[i].nativePath);
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/getDirectoryListingAsync()" class="- topic/link "><linktext class="- topic/linktext ">getDirectoryListingAsync()</linktext></link><link href="flash.filesystem.xml#File/getRootDirectories()" class="- topic/link "><linktext class="- topic/linktext ">getRootDirectories()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:getRelativePath" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">getRelativePath</apiName><shortdesc class="- topic/shortdesc ">
	 查找两个 File 路径之间的相对路径。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">该引用为 <codeph class="+ topic/ph pr-d/codeph ">null</codeph>。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">ArgumentError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">ArgumentError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">调用方不在应用程序安全沙箱中。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">如果可能，则为此文件（或目录）和 <codeph class="+ topic/ph pr-d/codeph ">ref</codeph> 文件（或目录）之间的相对路径；否则为 <codeph class="+ topic/ph pr-d/codeph ">null</codeph>。
	 
	 </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">ref</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.net:FileReference</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc "> 针对其给定该路径的 File 对象。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">useDotDot</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">false</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc "> 指定生成的相对路径是否可以使用“..”组件。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 查找两个 File 路径之间的相对路径。
	 
	 <p class="- topic/p ">相对路径是可以追加到此引用（据此引用进行解析）以便定位第二个（参数）引用的组件的列表。使用“/”分隔符返回相对路径。</p>
	 
	 <p class="- topic/p ">或者，相对路径可以包括“..”引用，但这样的路径将不能跨越明显的卷边界。</p>
	 
	 </apiDesc><example conref="examples\File.getRelativePath.1.as" class="- topic/example "/></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:getRootDirectories" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">getRootDirectories</apiName><shortdesc class="- topic/shortdesc ">
	 返回 File 对象的数组，列出文件系统根目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">File 对象的数组，列出各个根目录。 
	 
	 </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 返回 File 对象的数组，列出文件系统根目录。 
	 
	 <p class="- topic/p ">例如在 Windows 中，这是一个卷列表，如 C: 驱动器和 D: 驱动器。此数组中不包括空的驱动器，如未插入光盘的 CD 或 DVD 驱动器。在 Mac OS 和 Linux 中，此方法始终返回计算机的唯一根目录（“/”目录）</p>
	 
	 <p class="- topic/p ">在根不可读的文件系统上，例如 Android 文件系统，返回的 File 对象的属性并不总是反映真实值。例如，在 Android 上，<codeph class="+ topic/ph pr-d/codeph ">spaceAvailable</codeph> 属性报告 0。</p>
	 
	 </apiDesc><example conref="examples\File.getRootDirectories.1.as" class="- topic/example "> 下面的代码输出根目录的列表：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
var rootDirs:Array = File.getRootDirectories();

for (var i:uint = 0; i &lt; rootDirs.length; i++) {
    trace(rootDirs[i].nativePath);
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:moveToAsync" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">moveToAsync</apiName><shortdesc class="- topic/shortdesc ">
	 开始将此 File 对象指定的位置中的文件或目录移动到 newLocation 参数指定的位置。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有移动文件的必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">newLocation</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.net:FileReference</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">移动的目标位置。此对象指定生成（移动）的文件或目录的路径，<i class="+ topic/ph hi-d/i ">不是</i> 包含该文件或目录的目录的路径。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">overwrite</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">false</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">如果为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>，则当 <codeph class="+ topic/ph pr-d/codeph ">target</codeph> 文件已经存在时移动将失败。如果为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，则该操作将覆盖任何现有的同名文件或目录。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 开始将此 File 对象指定的位置中的文件或目录移动到 <codeph class="+ topic/ph pr-d/codeph ">newLocation</codeph> 参数指定的位置。 
	 
	 <p class="- topic/p ">要重命名文件，请将 <codeph class="+ topic/ph pr-d/codeph ">destination</codeph> 参数设置为指向该文件目录中的路径，但使用不同的文件名。</p>
	 
	 <p class="- topic/p ">移动过程将创建任何需要的父目录（如有可能）。</p>
	 
	 </apiDesc><example conref="examples\File.moveToAsync.1.as" class="- topic/example "> 下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">moveToAsync()</codeph> 方法重命名文件。原始文件名为 test1.txt，生成的文件名为 test2.txt。由于源和目标 File 对象都指向同一个目录（用户文档目录的 Apollo Test 子目录），<codeph class="+ topic/ph pr-d/codeph ">moveToAsync()</codeph> 方法将重命名该文件（而不是将它移动到新的目录中）。在运行此代码之前，在计算机上文档目录的 Apollo Test 子目录中创建一个 test1.txt 文件。将 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 参数设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph> 时，此操作将覆盖任何现有的 test2.txt 文件。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("Apollo Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("Apollo Test/test2.txt");

var sourceFile.moveToAsync(destination, true);
sourceFile.addEventListener(Event.COMPLETE, fileMoveCompleteHandler);

function fileMoveCompleteHandler(event:Event):void 
{
    trace("Done.")
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/copyToAsync()" class="- topic/link "><linktext class="- topic/linktext ">copyToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveTo()" class="- topic/link "><linktext class="- topic/linktext ">moveTo()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()" class="- topic/link "><linktext class="- topic/linktext ">moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:moveToAsync_complete" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">complete</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在文件或目录已成功移动时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在文件或目录已成功移动时调度。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:moveToAsync_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">源不存在；或者目标存在而 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>；或者无法将源移动到目标；或者源和目标引用相同的文件或文件夹且 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>。在 Windows 中无法移动打开的文件，也无法移动包含已打开文件的目录。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">源不存在；或目标存在但 overwrite 为 false；或无法将源移到目标；或源和目标引用相同的文件或文件夹但 overwrite 设置为 true。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:moveToTrashAsync" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">moveToTrashAsync</apiName><shortdesc class="- topic/shortdesc ">
	 将文件或目录异步移动到垃圾桶。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata><asCustoms class="+ topic/metadata adobe-api-d/asCustoms "><internal>TBC: what to do when Trash is not supported?  SB part of general policy about optional system facilities.
	 </internal></asCustoms></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有将文件移动到垃圾桶的必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 将文件或目录异步移动到垃圾桶。 
	 
	 <p class="- topic/p "><b class="+ topic/ph hi-d/b ">注意：</b>在不支持可恢复垃圾桶文件夹概念的操作系统上，会立即删除文件。</p>
	 
	 </apiDesc></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/moveToTrash()" class="- topic/link "><linktext class="- topic/linktext ">moveToTrash()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:moveToTrashAsync_ioError" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">ioError</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">操作系统不允许该操作；或者文件或目录不存在。在 Windows 中无法移动打开的文件，也无法移动包含当前打开的文件的目录。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">操作系统不允许该操作；或者文件或目录不存在。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:moveToTrashAsync_complete" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef adobeApiEvent/adobeApiEvent "><apiName class="- topic/title reference/title apiRef/apiName ">complete</apiName><prolog class="- topic/prolog "/><adobeApiEventDetail class="- topic/body reference/refbody apiRef/apiDetail adobeApiEvent/adobeApiEventDetail "><adobeApiEventDef class="- topic/section reference/section apiRef/apiDef adobeApiEvent/adobeApiEventDef "><adobeApiEventClassifier class="- topic/xref reference/xref apiRef/apiRelation adobeApiEvent/adobeApiEventClassifier ">flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent class="- topic/state reference/state apiRef/apiQualifier adobeApiEvent/apiGeneratedEvent "/></adobeApiEventDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">在文件或目录已成功移动到垃圾桶时调度。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc class="- topic/shortdesc ">在文件或目录已成功移动到垃圾桶时调度。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:moveToTrash" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">moveToTrash</apiName><shortdesc class="- topic/shortdesc ">
	 将文件或目录移动到垃圾桶。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata><asCustoms class="+ topic/metadata adobe-api-d/asCustoms "><internal>TBC: what to do when Trash is not supported?  SB part of general policy about optional system facilities.
	 </internal></asCustoms></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">操作系统不允许该操作；或者文件或目录不存在。在 Windows 中无法移动打开的文件，也无法移动包含当前打开的文件的目录。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有将文件移动到垃圾桶的必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 将文件或目录移动到垃圾桶。
	 
	 <p class="- topic/p "><b class="+ topic/ph hi-d/b ">注意：</b>在不支持可恢复垃圾桶文件夹概念的操作系统上，会立即删除文件。</p>
	 
	 </apiDesc></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/moveToTrashAsync()" class="- topic/link "><linktext class="- topic/linktext ">moveToTrashAsync()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:moveTo" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">moveTo</apiName><shortdesc class="- topic/shortdesc ">
	 将此 File 对象指定的位置中的文件或目录移动到 destination 参数指定的位置。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">源不存在；或者目标存在且 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 设置为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>；或者无法将源文件或目录移动到目标位置；或者源和目标引用相同的文件或文件夹且 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>。在 Windows 中无法移动打开的文件，也无法移动包含已打开文件的目录。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">应用程序没有移动文件的必要权限。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">newLocation</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.net:FileReference</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">移动的目标位置。此对象指定生成（移动）的文件或目录的路径，<i class="+ topic/ph hi-d/i ">不是</i> 包含该文件或目录的目录的路径。
	 
	 </apiDesc></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">overwrite</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier><apiData class="- topic/ph reference/ph apiRef/apiData ">false</apiData><apiDesc class="- topic/section reference/section apiRef/apiDesc ">如果为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>，则当 <codeph class="+ topic/ph pr-d/codeph ">target</codeph> 文件已经存在时移动将失败。如果为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>，则该操作将覆盖任何现有的同名文件或目录。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 将此 File 对象指定的位置中的文件或目录移动到 <codeph class="+ topic/ph pr-d/codeph ">destination</codeph> 参数指定的位置。 
	 
	 <p class="- topic/p ">要重命名文件，请将 <codeph class="+ topic/ph pr-d/codeph ">destination</codeph> 参数设置为指向该文件目录中的路径，但使用不同的文件名。</p>
	 
	 <p class="- topic/p ">移动过程将创建任何需要的父目录（如有可能）。</p>
	 
	 </apiDesc><example conref="examples\File.moveTo.1.as" class="- topic/example "> 下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">moveTo()</codeph> 方法重命名文件。原始文件名为 test1.txt，生成的文件名为 test2.txt。由于源和目标 File 对象都指向同一个目录（用户文档目录的 Apollo Test 子目录），<codeph class="+ topic/ph pr-d/codeph ">moveTo()</codeph> 方法将重命名该文件（而不是将它移动到新的目录中）。运行此代码之前，请在计算机上文档目录的 AIR Test 子目录中创建一个 test1.txt 文件。将 <codeph class="+ topic/ph pr-d/codeph ">overwrite</codeph> 参数设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph> 时，此操作将覆盖任何现有的 test2.txt 文件。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">

import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("Apollo Test/test2.txt");

try  
{
    sourceFile.moveTo(destination, true);
}
catch (error:Error)
{
    trace("Error:" + error.message);
}
</codeblock></example><example conref="examples\File.moveTo.2.as" class="- topic/example "> 下面的代码显示如何使用 <codeph class="+ topic/ph pr-d/codeph ">moveTo()</codeph> 方法移动文件。原始文件（test1.txt 文件）位于用户文档目录的 Apollo Test 子目录中，该方法将该文件移动到 Results 子目录中。运行此代码之前，在计算机上主目录的 AIR Test 子目录中创建一个 test1.txt 文件。<codeph class="+ topic/ph pr-d/codeph ">try</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">catch</codeph> 语句显示如何响应错误。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/Results/test1.txt");

try 
{
    sourceFile.moveTo(destination, true);
}
catch (error:Error)
{
    trace("Error:" + error.message);
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/copyTo()" class="- topic/link "><linktext class="- topic/linktext ">copyTo()</linktext></link><link href="flash.filesystem.xml#File/moveToAsync()" class="- topic/link "><linktext class="- topic/linktext ">moveToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()" class="- topic/link "><linktext class="- topic/linktext ">moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:openWithDefaultApplication" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">openWithDefaultApplication</apiName><shortdesc class="- topic/shortdesc ">
	 打开操作系统注册的应用程序中的文件来打开此类型的文件。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">（Mac OS 和 Linux）未找到能打开此文件的应用程序。（在 Windows 上，试图打开无关联应用程序的文件失败，没有提示，也无异常发生。）
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">Error</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Error</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件位于应用程序目录中，或文件类型属于是禁止的文件类型。此错误对于使用本机应用程序安装程序（扩展桌面配置文件应用程序）安装的 AIR 应用程序不适用。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IllegalOperationError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件不存在或没有注册打开该文件的应用程序。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">IOError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.errors:IOError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">文件不存在。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">ReferenceError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">ReferenceError</apiOperationClassifier></apiException><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiType value="void" name="type" class="- topic/state reference/state apiRef/apiType "/></apiReturn></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 打开操作系统注册的应用程序中的文件来打开此类型的文件。
	 
	 <p class="- topic/p ">AIR 阻止您使用 File.openWithDefaultApplication() 方法打开特定文件。在 Windows 上，AIR 阻止您打开某些文件类型的文件（具有特定扩展名的文件，如下所示）。在 Mac OS 和 Linux 上，AIR 会阻止您打开在下面指定的特定应用程序中启动的文件。尝试使用 <codeph class="+ topic/ph pr-d/codeph ">openWithDefaultApplication()</codeph> 方法打开其中一个文件将导致异常。但是，使用本机安装程序（扩展的桌面配置文件应用程序）安装的 AIR 应用程序不受限于这些限制；它们可以打开任何类型的文件。</p>
	 
	 <p class="- topic/p ">无法从应用程序目录中打开文档。</p>
	 
	 <p class="- topic/p ">下列表列出了在 Windows 上禁止的文件扩展名，以及在 Mac OS 和 Linux 上阻止的应用程序：</p>
	 
	 <p class="- topic/p ">
	 <adobetable class="innertable"><tgroup cols="4" class="- topic/tgroup "><thead class="- topic/thead "><row class="- topic/row "><entry class="- topic/entry "> Windows 文档扩展名 </entry><entry class="- topic/entry "> 类型 </entry><entry class="- topic/entry "> Mac OS 应用程序对应项 </entry><entry class="- topic/entry "> Linux 应用程序对应项 </entry></row></thead><tbody class="- topic/tbody "><row class="- topic/row "><entry class="- topic/entry "> bat </entry><entry class="- topic/entry "> 批处理文件命令 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> 无默认应用程序 </entry></row><row class="- topic/row "><entry class="- topic/entry "> cmd </entry><entry class="- topic/entry "> DOS 和 Windows 命令文件 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> 无默认应用程序 </entry></row><row class="- topic/row "><entry class="- topic/entry "> com </entry><entry class="- topic/entry "> 命令 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> 无默认应用程序 </entry></row><row class="- topic/row "><entry class="- topic/entry "> csh </entry><entry class="- topic/entry "> UNIX csh shell 脚本 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> /bin/csh </entry></row><row class="- topic/row "><entry class="- topic/entry "> 短划线 </entry><entry class="- topic/entry "> UNIX dash shell 脚本 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> /bin/dash </entry></row><row class="- topic/row "><entry class="- topic/entry "> ksh </entry><entry class="- topic/entry "> UNIX ksh shell 脚本 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> /bin/ksh </entry></row><row class="- topic/row "><entry class="- topic/entry "> sh </entry><entry class="- topic/entry "> UNIX shell 脚本 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> /bin/bash </entry></row><row class="- topic/row "><entry class="- topic/entry "> tcsh </entry><entry class="- topic/entry "> UNIX tcsh shell 脚本 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> /bin/tcsh </entry></row><row class="- topic/row "><entry class="- topic/entry "> zsh </entry><entry class="- topic/entry "> UNIX zsh shell 脚本 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> /bin/zsh </entry></row><row class="- topic/row "><entry class="- topic/entry "> exe </entry><entry class="- topic/entry "> 可执行文件 </entry><entry class="- topic/entry "> 可执行文件位，.app 扩展名 </entry><entry class="- topic/entry "> /lib/ld.so </entry></row><row class="- topic/row "><entry class="- topic/entry "> lnk </entry><entry class="- topic/entry "> Windows 快捷方式文件 </entry><entry class="- topic/entry "> 可执行文件位，.app 扩展名 </entry><entry class="- topic/entry "> Linux 中的链接，可执行位集，无默认应用程序 </entry></row><row class="- topic/row "><entry class="- topic/entry "> pif </entry><entry class="- topic/entry "> 程序信息文件 </entry><entry class="- topic/entry "> 可执行文件位，.app 扩展名 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> reg </entry><entry class="- topic/entry "> 注册信息/Windows 95/98 键，注册表数据文件 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> scf </entry><entry class="- topic/entry "> Windows 资源管理器命令 </entry><entry class="- topic/entry "> ScriptEditor、AutomatorRunner </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> shb, shs </entry><entry class="- topic/entry "> Shell 碎片对象文件 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> prg </entry><entry class="- topic/entry "> 程序文件 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> vb、vbe、vbs </entry><entry class="- topic/entry "> VBScript 文件 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> vsmacros </entry><entry class="- topic/entry "> 基于 Visual Studio .NET 二进制的宏项目 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> ws、wsc、wsf、wsh </entry><entry class="- topic/entry "> Windows 脚本文件 </entry><entry class="- topic/entry "> ScriptEditor、AutomatorRunner </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> fxp </entry><entry class="- topic/entry "> Fox Pro 编译的源代码 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> mas </entry><entry class="- topic/entry "> Microsoft Access 存储过程 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> scr </entry><entry class="- topic/entry "> Windows 屏幕保护程序 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> py、pyc </entry><entry class="- topic/entry "> Python 脚本文件 </entry><entry class="- topic/entry "> Python </entry><entry class="- topic/entry "> Python </entry></row><row class="- topic/row "><entry class="- topic/entry "> pl </entry><entry class="- topic/entry "> Perl 脚本文件 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> perl </entry></row><row class="- topic/row "><entry class="- topic/entry "> cgi </entry><entry class="- topic/entry "> 通用网关接口脚本文件 </entry><entry class="- topic/entry "> 终端 </entry><entry class="- topic/entry "> perl </entry></row><row class="- topic/row "><entry class="- topic/entry "> msi、msm、msp、mst、idt、cub、pcp </entry><entry class="- topic/entry "> Windows 安装程序文件 </entry><entry class="- topic/entry "> 安装程序 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> 作业 </entry><entry class="- topic/entry "> Windows 任务计划程序任务对象 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> jar、js, jse </entry><entry class="- topic/entry "> Java 归档文件，JavaScript 文件，JScript 编码脚本文件 </entry><entry class="- topic/entry "> <ph class="- topic/ph ">JarLauncher</ph> </entry><entry class="- topic/entry "> jar </entry></row><row class="- topic/row "><entry class="- topic/entry "> url </entry><entry class="- topic/entry "> Internet 快捷方式 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> hta </entry><entry class="- topic/entry "> HTML 应用程序 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 不适用 </entry></row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p class="- topic/p ">
	 <adobetable class="innertable"><tgroup cols="4" class="- topic/tgroup "><thead class="- topic/thead "><row class="- topic/row "><entry class="- topic/entry "> 仅限 Mac OS X </entry><entry class="- topic/entry "> 类型 </entry><entry class="- topic/entry "> Mac OS X 应用程序 </entry><entry class="- topic/entry "> Linux 应用程序对应项 </entry></row></thead><tbody class="- topic/tbody "><row class="- topic/row "><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> Mac OS X Java 小程序 </entry><entry class="- topic/entry "> AppletLauncher </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> Mac OS X AppleScript 插件 </entry><entry class="- topic/entry "> systemevents </entry><entry class="- topic/entry "> 不适用 </entry></row><row class="- topic/row "><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> Mac OS X 小部件 </entry><entry class="- topic/entry "> 停靠，dashboardlauncher </entry><entry class="- topic/entry "> 不适用 </entry></row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p class="- topic/p ">
	 <adobetable class="innertable"><tgroup cols="4" class="- topic/tgroup "><thead class="- topic/thead "><row class="- topic/row "><entry class="- topic/entry "> 仅限 Linux 的文档扩展名 </entry><entry class="- topic/entry "> 类型 </entry><entry class="- topic/entry "> Mac OS X 应用程序对应项 </entry><entry class="- topic/entry "> Linux 应用程序 </entry></row></thead><tbody class="- topic/tbody "><row class="- topic/row "><entry class="- topic/entry "> rb </entry><entry class="- topic/entry "> Ruby shell 脚本 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> ruby </entry></row><row class="- topic/row "><entry class="- topic/entry "> 桌面 </entry><entry class="- topic/entry "> 桌面文件和快捷方式 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 无默认应用程序 </entry></row><row class="- topic/row "><entry class="- topic/entry "> 目录 </entry><entry class="- topic/entry "> 目录文件和快捷方式 </entry><entry class="- topic/entry "> 不适用 </entry><entry class="- topic/entry "> 无默认应用程序 </entry></row></tbody></tgroup></adobetable>
	 </p>
	 	 
	 	 
	 </apiDesc><example conref="examples\File.openWithDefaultApplication.1.as" class="- topic/example "> 使用以下代码，用户可导航到 MP3 文件并在播放 MP3 文件的默认应用程序中将其打开。 
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
import flash.net.FileFilter;

var file:File = File.documentsDirectory; 
var mp3Filter:FileFilter = new FileFilter("MP3 Files", "*.mp3"); 
file.browseForOpen("Open", [mp3Filter]); 
file.addEventListener(Event.SELECT, fileSelected); 
 
function fileSelected(e:Event):void 
{ 
    file.openWithDefaultApplication(); 
}
</codeblock></example></apiOperationDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/downloaded" class="- topic/link "><linktext class="- topic/linktext ">downloaded</linktext></link><link href="flash.desktop.xml#NativeProcess" class="- topic/link "><linktext class="- topic/linktext ">NativeProcess</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:resolvePath" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation "><apiName class="- topic/title reference/title apiRef/apiName ">resolvePath</apiName><shortdesc class="- topic/shortdesc ">
	 基于 path 参数（一个字符串）创建一个其路径相对于此 File 对象路径的新 File 对象。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiOperationDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail "><apiOperationDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiOperationDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiReturn class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiReturn "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">指向生成的路径的新 File 对象。
	 
	 </apiDesc><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.filesystem:File</apiOperationClassifier></apiReturn><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">path</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier><apiDesc class="- topic/section reference/section apiRef/apiDesc ">要追加到此 File 对象的路径中的路径（如果 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数为相对路径）；或者要返回的路径（如果 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数为绝对路径）。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 基于 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数（一个字符串）创建一个其路径相对于此 File 对象路径的新 File 对象。
	 
	 <p class="- topic/p "><codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数可以使用相对路径或绝对路径。</p>
	 
	 <p class="- topic/p ">如果指定相对路径，则将给定的 <codeph class="+ topic/ph pr-d/codeph ">path</codeph>“追加”到 File 对象的路径。但是，在 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 中使用“..”可以返回生成的路径（该路径不是 File 对象的子级）。生成的引用不必引用实际文件系统位置。</p>
	 
	 <p class="- topic/p ">如果指定一个绝对文件引用，则该方法将返回指向该路径的 File 对象。绝对文件引用应使用对用户的操作系统有效的本机路径语法（例如 Windows 上的 <codeph class="+ topic/ph pr-d/codeph ">"C:\\test"</codeph>）。<i class="+ topic/ph hi-d/i ">不要</i>将 URL（例如 <codeph class="+ topic/ph pr-d/codeph ">"file:///c:/test"</codeph>）用作 <codeph class="+ topic/ph pr-d/codeph ">path</codeph> 参数。</p>
	 
	 <p class="- topic/p ">所有生成的路径将按以下方式进行规范化： </p>
	 
	 <ul class="- topic/ul "><li class="- topic/li ">任何 "." 忽略元素。</li><li class="- topic/li ">任何 ".." 元素使用其父级条目。  </li><li class="- topic/li ">否 ".." 到达文件系统根或应用程序的永久存储区根的引用通过该节点；将忽略该引用。</li></ul>
	 
	 <p class="- topic/p ">应始终使用正斜杠 (<codeph class="+ topic/ph pr-d/codeph ">/</codeph>) 字符作为路径分隔符。在 Windows 上，也可以<i class="+ topic/ph hi-d/i "/>使用反斜杠 (<codeph class="+ topic/ph pr-d/codeph ">\</codeph>) 字符，但最好不要使用它。使用反斜杠字符可导致应用程序在其他平台上无法运行。</p>
	 
	 <p class="- topic/p ">在 Linux 上，文件名和目录名是区分大小写的。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filesystem:File:applicationDirectory:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">applicationDirectory</apiName><shortdesc class="- topic/shortdesc ">
	 包含应用程序已安装文件的文件夹。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 包含应用程序已安装文件的文件夹。
	 
	 <p class="- topic/p ">此对象的 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性使用 <codeph class="+ topic/ph pr-d/codeph ">app</codeph> URL 架构（而不是 <codeph class="+ topic/ph pr-d/codeph ">file</codeph> URL 架构）。这意味着指定的 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 以<codeph class="+ topic/ph pr-d/codeph ">"app:"</codeph>开头（而不是以 <codeph class="+ topic/ph pr-d/codeph ">"file:"</codeph> 开头）。此外，如果创建一个相对于 <codeph class="+ topic/ph pr-d/codeph ">File.applicationDirectory</codeph> 目录的 File 对象（通过使用 <codeph class="+ topic/ph pr-d/codeph ">resolvePath()</codeph> 方法），则该 File 对象的 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 也使用 <codeph class="+ topic/ph pr-d/codeph ">app</codeph> URL 架构。 
	 </p>
	 
	 <p class="- topic/p "><i class="+ topic/ph hi-d/i ">注意：</i>您无法写入其路径使用 <codeph class="+ topic/ph pr-d/codeph ">app:</codeph> URL 方案的文件或目录。您也无法删除或创建其路径使用 <codeph class="+ topic/ph pr-d/codeph ">app:</codeph> URL 方案的文件或文件夹。出于安全原因，不推荐修改应用程序目录中的内容，有些平台上的操作系统会阻止此操作。如果要存储特定于应用程序的数据，请考虑使用应用程序存储目录 (<codeph class="+ topic/ph pr-d/codeph ">File.applicationStorageDirectory</codeph>)。如果希望应用程序存储目录中的任何内容能够访问应用程序特许功能 (AIR API)，您可以通过使用沙箱桥公开该功能。</p>
	 
	 
	 <p class="- topic/p "><codeph class="+ topic/ph pr-d/codeph ">applicationDirectory</codeph> 属性可用于引用应用程序目录，它在所有平台上均有效。如果使用 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性设置 File 对象，使其引用应用程序目录，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 <p class="- topic/p ">在 Android 上，指向应用程序目录的 File 对象的 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 属性是空字符串。使用 <codeph class="+ topic/ph pr-d/codeph ">URL</codeph> 属性访问应用程序文件。</p> 
	 </apiDesc></apiValueDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/applicationStorageDirectory" class="- topic/link "><linktext class="- topic/linktext ">applicationStorageDirectory</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:applicationStorageDirectory:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">applicationStorageDirectory</apiName><shortdesc class="- topic/shortdesc ">
     应用程序的专用存储目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
     应用程序的专用存储目录。 
	 
	 <p class="- topic/p ">每个 AIR 应用程序都有一个唯一的、永久的应用程序存储目录，该目录是您首次访问 <codeph class="+ topic/ph pr-d/codeph ">File.applicationStorageDirectory</codeph> 时创建的。此目录是存储特定于应用程序的数据的方便位置。</p>
	 
	 <p class="- topic/p ">卸载 AIR 应用程序时，卸载程序是否删除应用程序存储目录及其文件取决于平台。</p>
	 
	 <p class="- topic/p ">此对象的 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性使用 <codeph class="+ topic/ph pr-d/codeph ">app-storage</codeph> URL 架构（而不是 <codeph class="+ topic/ph pr-d/codeph ">file</codeph> URL 架构）。这意味着指定的 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 字符串以<codeph class="+ topic/ph pr-d/codeph ">"app-storage:"</codeph>开头（而不是以 <codeph class="+ topic/ph pr-d/codeph ">"file:"</codeph> 开头）。此外，如果创建一个相对于 <codeph class="+ topic/ph pr-d/codeph ">File.applicationStoreDirectory</codeph> 目录的 File 对象（通过使用 <codeph class="+ topic/ph pr-d/codeph ">resolvePath()</codeph> 方法），则该 File 对象的 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 也使用 <codeph class="+ topic/ph pr-d/codeph ">app-storage</codeph> URL 架构（如示例中所示）。</p>
	 
	 <p class="- topic/p "><codeph class="+ topic/ph pr-d/codeph ">applicationStorageDirectory</codeph> 属性可用于引用应用程序存储目录，它在所有平台上均有效。如果使用 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性设置 File 对象，使其引用应用程序存储目录，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 
	 </apiDesc><example conref="examples\File.applicationStorageDirectory.1.as" class="- topic/example "> 下面的代码创建一个 File 对象，该对象指向应用程序存储目录中的“images”子目录。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var tempFiles:File = File.applicationStorageDirectory;
tempFiles = tempFiles.resolvePath("images/");
trace(tempFiles.url); // app-storage:/images
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:desktopDirectory:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">desktopDirectory</apiName><shortdesc class="- topic/shortdesc ">
	 用户桌面目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 用户桌面目录。
	 
	 <p class="- topic/p "><codeph class="+ topic/ph pr-d/codeph ">desktopDirectory</codeph> 属性可用于引用桌面目录，它在所有平台上均有效。如果使用 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性设置 File 对象，使其引用桌面目录，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 <p class="- topic/p ">如果操作系统不支持桌面目录，则使用文件系统中适当的目录。</p>
	 
  	 <p class="- topic/p ">用于电视的 AIR 没有用户桌面目录的概念。因此，<codeph class="+ topic/ph pr-d/codeph ">desktopDirectory</codeph> 属性引用与 <codeph class="+ topic/ph pr-d/codeph ">File.userDirectory</codeph> 属性相同的目录位置。用户目录对于应用程序而言是唯一的。</p>	 
	 	 
	 
	 </apiDesc><example conref="examples\File.desktopDirectory.1.as" class="- topic/example "> 下面的代码输出用户桌面目录中包含的文件和目录的列表。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
var desktop:File = File.desktopDirectory;

var files:Array = desktop.getDirectoryListing();

for (var i:uint = 0; i &lt; files.length; i++) {
    trace(files[i].nativePath);
}
</codeblock><swfblock conref="examples\File.desktopDirectory.1.swf" xml:space="preserve"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:documentsDirectory:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">documentsDirectory</apiName><shortdesc class="- topic/shortdesc ">
	 用户文档目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 用户文档目录。
	 
	 <p class="- topic/p ">在 Windows 中，这是“My Documents”目录（例如，C:\Documents and Settings\userName\My Documents）。在 Mac OS 中，默认位置是 /Users/userName/Documents。在 Linux 中，默认位置是 /home/userName/Documents（英语系统上），并且该属性遵守 <codeph class="+ topic/ph pr-d/codeph ">xdg-user-dirs</codeph> 设置。</p>
	 
	 
	 <p class="- topic/p "><codeph class="+ topic/ph pr-d/codeph ">documentsDirectory</codeph> 属性可用于引用文档目录，它在所有平台上均有效。如果使用 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性设置 File 对象，使其引用文档目录，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 <p class="- topic/p ">如果操作系统不支持文档目录，则使用文件系统中适当的目录。</p>
	 
  	 <p class="- topic/p ">用于电视的 AIR 设备没有用户文档目录的概念。因此，<codeph class="+ topic/ph pr-d/codeph ">documentsDirectory</codeph> 属性引用与 <codeph class="+ topic/ph pr-d/codeph ">File.userDirectory</codeph> 属性相同的目录位置。用户目录对于应用程序而言是唯一的。</p>	 
	 
	 </apiDesc><example conref="examples\File.documentsDirectory.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">File.documentsDirectory</codeph> 属性和 <codeph class="+ topic/ph pr-d/codeph ">File.createDirectory()</codeph> 方法来确保用户文档目录中存在一个名为“AIR Test”的目录。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var directory:File = File.documentsDirectory;
directory = directory.resolvePath("AIR Test");

File.createDirectory(directory);
trace(directory.exists); // true
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:downloaded:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">downloaded</apiName><shortdesc class="- topic/shortdesc ">
	 表示是否已（从 Internet）下载参考文件或目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="readwrite" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 表示是否已（从 Internet）下载参考文件或目录。
	 
	 <p class="- topic/p ">此属性仅在文件可以标记为已下载的操作系统上有意义：</p>
	 
	 <ul class="- topic/ul "><li class="- topic/li ">Windows XP Service Pack 2 和更高版本，在 Windows Vista 上</li><li class="- topic/li ">Mac OS 10.5 和更高版本</li></ul>
	 
	 <p class="- topic/p ">在 Linux 等不标记已下载文件的系统上，此属性没有意义（其值设置为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>）。</p>
	 
	 </apiDesc></apiValueDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/openWithDefaultApplication()" class="- topic/link "><linktext class="- topic/linktext ">openWithDefaultApplication()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:exists:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">exists</apiName><shortdesc class="- topic/shortdesc ">
     表示引用的文件或目录是否存在。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
     表示引用的文件或目录是否存在。如果 File 对象指向现有的文件或目录，则该值为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>；否则为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。
	 
	 </apiDesc><example conref="examples\File.exists.1.as" class="- topic/example "> 下面的代码创建一个临时文件，然后将其删除，并使用 <codeph class="+ topic/ph pr-d/codeph ">File.exists</codeph> 属性来检查该文件是否存在。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var temp:File = File.createTempFile();
trace(temp.exists); // true
temp.deleteFile();
trace(temp.exists); // false
</codeblock><swfblock conref="examples\File.exists.1.swf" xml:space="preserve"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:icon:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">icon</apiName><shortdesc class="- topic/shortdesc ">
	 包含为文件定义的图标的 Icon 对象。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.desktop:Icon</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 包含为文件定义的图标的 Icon 对象。Icon 对象是与各种图标状态相对应的 BitmapData 对象的数组。在 Linux 中，Icon 对象不包含图标。在 Android 上，<codeph class="+ topic/ph pr-d/codeph ">icon</codeph> 属性为 <codeph class="+ topic/ph pr-d/codeph ">null</codeph>。
	 
	 </apiDesc><example conref="examples\File.icon.1.as" class="- topic/example "> 下面的代码显示如何在 <codeph class="+ topic/ph pr-d/codeph ">icon</codeph> 数组中查找具有最大高度的图像，并将该图像设置为 Bitmap 对象。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;
import flash.display.*;

var directory:File = File.documentsDirectory;
var bitmaps:Array = directory.icon.bitmaps;
var bmpData:BitmapData = new BitmapData(1, 1);
for (var i:uint = 0; i &lt; bitmaps.length; i++) {
    if (bitmaps[i].height > bmpData.height) {
        bmpData = directory.icon.bitmaps[i];
    }
}
var iconBmp:Bitmap = new Bitmap(bmpData);
</codeblock> 您可以将此 Bitmap 对象作为显示对象容器的子项（如 Sprite 对象或 Flex UIComponent 对象）进行添加。
</example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isDirectory:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">isDirectory</apiName><shortdesc class="- topic/shortdesc ">
     表示是否为对目录的引用。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
     表示是否为对目录的引用。如果 File 对象指向一个目录，则该值为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>；否则为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。
	 
	 </apiDesc><example conref="examples\File.isDirectory.1.as" class="- topic/example "> 下面的代码创建指向用户目录中文件和目录的 File 对象的数组，然后使用 <codeph class="+ topic/ph pr-d/codeph ">isDirectory</codeph> 属性仅列出指向目录（而不是文件）的那些 File 对象。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var userDirFiles:Array = File.userDirectory.getDirectoryListing();
for (var i:uint = 0; i &lt; userDirFiles.length; i++) {
    if (userDirFiles[i].isDirectory) {
        trace(userDirFiles[i].nativePath);
    }
}    
</codeblock><swfblock conref="examples\File.isDirectory.1.swf" xml:space="preserve"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isHidden:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">isHidden</apiName><shortdesc class="- topic/shortdesc ">
     表示引用的文件或目录是否为“隐藏”。如果引用的文件或目录是隐藏的，则该值为 true；否则为 false。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata><asCustoms class="+ topic/metadata adobe-api-d/asCustoms "><internal>(Waiting for Stan's OK:)
	 
	 <ul class="- topic/ul "><li class="- topic/li ">On Windows, a file or directory is designated as hidden by specifying the 
	 Hidden attribute (for example, in the File Properties dialog box) for the file.</li><li class="- topic/li ">On Mac OS and Linux, files can be designated as hidden for a number of reasons. Files with 
	 names that begin with the dot (.) character are designated as hidden. A .hidden file 
	 in the root directory lists other hidden files. Also, there is a bit in the file that, 
	 when set, makes it hidden.</li></ul>
	 
	 </internal></asCustoms></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
     表示引用的文件或目录是否为“隐藏”。如果引用的文件或目录是隐藏的，则该值为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>；否则为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。
	 
	 </apiDesc><example conref="examples\File.isHidden.1.as" class="- topic/example "> 下面的代码创建指向用户目录中文件和目录的 File 对象的数组，然后使用 <codeph class="+ topic/ph pr-d/codeph ">isHidden</codeph> 属性列出隐藏的文件和目录。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var userDirFiles:Array = File.userDirectory.getDirectoryListing();
for (var i:uint = 0; i &lt; userDirFiles.length; i++) {
    if (userDirFiles[i].isHidden) {
        trace(userDirFiles[i].nativePath);
    }
}    
</codeblock><swfblock conref="examples\File.isHidden.1.swf" xml:space="preserve"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isPackage:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">isPackage</apiName><shortdesc class="- topic/shortdesc ">
     表示引用的目录是否为包。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
     表示引用的目录是否为包。
     
	 <p class="- topic/p ">如果引用的目录是包，则该值为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>；否则为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。请注意，File 类不允许直接创建包。</p>
	 
	 <ul class="- topic/ul "><li class="- topic/li ">在 Mac OS 中，目录可以指定为包并将作为单个文件而不是目录显示在 Finder 中。如果引用的目录是包，则将此属性设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>；如果该文件不是目录、不存在或不是包，则将此属性设置为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。</li><li class="- topic/li ">在其他操作系统上，此属性始终设置为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。</li></ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isSymbolicLink:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">isSymbolicLink</apiName><shortdesc class="- topic/shortdesc ">
     表示引用是否为符号链接。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
     表示引用是否为符号链接。
     
	 <p class="- topic/p ">如果 File 对象是一个符号链接，则该值为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>；否则为 <codeph class="+ topic/ph pr-d/codeph ">false</codeph>。请注意，File 类不允许直接创建符号链接。</p>
	 
	 <p class="- topic/p ">符号链接允许一个文件指向磁盘上的另一个文件或目录。符号链接虽然与 Mac OS 中的别名和 Windows 中的快捷方式相似，但并不相同。别名或快捷方式始终报告为文件（而不是目录），读取或写入别名或快捷方式从不影响它指向的原始文件或目录。另一方面，符号链接的行为大体上与其所指向的文件或目录类似。它可以报告为文件或目录，读取或写入符号链接将会影响它指向的文件或目录，而不影响符号链接本身。删除符号链接，但删除的是链接，而非链接的目标。</p>
	 
	 <p class="- topic/p ">Mac <sup class="+ topic/ph hi-d/sup ">®</sup> OS <sup class="+ topic/ph hi-d/sup ">®</sup>、Linux 和 Windows <sup class="+ topic/ph hi-d/sup ">®</sup> Vista <sup class="+ topic/ph hi-d/sup ">®</sup> 支持符号链接。此外，在 Windows 中，引用交接点（用于 NTFS 文件系统）的 File 对象的 <codeph class="+ topic/ph pr-d/codeph ">isSymbolicLink</codeph> 属性设置为 <codeph class="+ topic/ph pr-d/codeph ">true</codeph>。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:lineEnding:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">lineEnding</apiName><shortdesc class="- topic/shortdesc ">
	 主机操作系统使用的行结束字符序列。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 主机操作系统使用的行结束字符序列。
	 
	 <p class="- topic/p ">在 Mac OS 和 Linux 中，这是换行符（十六进制字符代码 0x0A）。在 Windows 中，它是回车符（十六进制字符代码 0x0D），后跟换行符（十六进制字符代码 0x0A）。</p>
	 
	 </apiDesc><example conref="examples\File.lineEnding.1.as" class="- topic/example "> 下面的代码将一个字符串 (<codeph class="+ topic/ph pr-d/codeph ">str</codeph>) 写入文本文件，并使用 <codeph class="+ topic/ph pr-d/codeph ">File.lineEnding</codeph> 静态属性，用主机操作系统首选的行尾符来替换换行符的所有实例（在代码中用正则表达式 <codeph class="+ topic/ph pr-d/codeph ">/\n/g</codeph> 表示）。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.*;

var str:String = "Hello\n" + 
        "World\n";
str = str.replace(/\n/g, File.lineEnding);
var file:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.WRITE);
fileStream.writeUTF(str);
fileStream.close();
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:nativePath:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">nativePath</apiName><shortdesc class="- topic/shortdesc ">
	 采用主机操作系统表示形式的完整路径。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="readwrite" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">路径的语法无效。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">ArgumentError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">ArgumentError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">调用方不在应用程序安全沙箱中。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 采用主机操作系统表示形式的完整路径。在 Mac OS 和 Linux 中，使用正斜杠 (/) 字符作为路径分隔符。但在 Windows 中，可以使用正斜杠字符或反斜杠 (\) 字符作为路径分隔符来<i class="+ topic/ph hi-d/i ">设置</i> <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 属性，AIR 会自动用相应的反斜杠字符来替换正斜杠。
	 
	<p class="- topic/p ">在使用 <i class="+ topic/ph hi-d/i ">set</i> 命令，以代码形式直接设置 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 属性之前，请考虑这是否会生成平台专用代码。例如，<codeph class="+ topic/ph pr-d/codeph ">“C:\\Documents and Settings\\bob\\Desktop”</codeph>这样的本机路径仅在 Windows 上有效。较好的方法是使用以下这些静态属性，它们可以表示常用目录，且在所有平台上均有效：</p>
	
	<ul class="- topic/ul "><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.applicationDirectory</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.applicationStorageDirectory</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.desktopDirectory</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.documentsDirectory</codeph></li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">File.userDirectory</codeph></li></ul>
	
	<p class="- topic/p ">可以使用 <codeph class="+ topic/ph pr-d/codeph ">resolvePath()</codeph> 方法获取这些目录的相对路径。</p>
	
	<p class="- topic/p ">某些 Flex API（如 SWFLoader 类的 <codeph class="+ topic/ph pr-d/codeph ">source</codeph> 属性）使用 URL（File 对象的 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性），而不使用本机路径（<codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 属性）。</p>
	
	
	
	 </apiDesc><example conref="examples\File.nativePath.1.as" class="- topic/example "> 下面的代码显示 File 对象的 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 属性和 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性之间的区别。注释将在示例 Windows 计算机上显示结果。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var docs:File = File.documentsDirectory;
trace(docs.nativePath); // C:\Documents and Settings\turing\My Documents
trace(docs.url); // file:///C:/Documents%20and%20Settings/turing/My%20Documents
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:parent:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">parent</apiName><shortdesc class="- topic/shortdesc ">
     包含此 File 对象引用的文件或目录的目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
     包含此 File 对象引用的文件或目录的目录。 
	 
	 <p class="- topic/p ">如果文件或目录不存在，则 <codeph class="+ topic/ph pr-d/codeph ">parent</codeph> 属性仍然返回指向包含目录的 File 对象（即使该目录不存在）。</p>
	 
	 <p class="- topic/p ">此属性与 <codeph class="+ topic/ph pr-d/codeph ">resolvePath("..")</codeph> 的返回值相同，只不过根目录的父级为 <codeph class="+ topic/ph pr-d/codeph ">null</codeph>。</p>
	 
	 </apiDesc><example conref="examples\File.parent.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">parent</codeph> 属性显示包含临时文件的目录。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var tempFile:File = File.createTempDirectory();
trace(tempFile.parent.nativePath);
tempFile.deleteFile();
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:separator:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">separator</apiName><shortdesc class="- topic/shortdesc ">
	 主机操作系统的路径组件分隔符。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 主机操作系统的路径组件分隔符。
	 
	 <p class="- topic/p ">在 Mac OS 和 Linux 中，这是正斜杠 (/) 字符。在 Windows 中，它是反斜杠 (\) 字符。</p>
	 
	 <p class="- topic/p "><i class="+ topic/ph hi-d/i ">注意：</i>当在字符串中使用反斜杠时，请记住键入该字符两次（例如<codeph class="+ topic/ph pr-d/codeph ">“directory\\file.ext”</codeph>）。字符串中的每一对反斜杠在字符串中均表示单个反斜杠。</p>
	 
	 </apiDesc><example conref="examples\File.separator.1.as" class="- topic/example "> 下面的代码使用 <codeph class="+ topic/ph pr-d/codeph ">getRelativePath()</codeph> 方法获取目录和文件之间的相对路径。然后，代码使用 <codeph class="+ topic/ph pr-d/codeph ">File.separator</codeph> 静态属性，用操作系统所用的分隔符来替换路径中的正斜杠 (/) 字符，在 Windows 中为反斜杠 (\)，在其他操作系统中为正斜杠。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var directory:File = File.documentsDirectory.resolvePath("Apollo Test");
var file:File = File.documentsDirectory.resolvePath("Apollo Test/employees/bob/test.txt");

var relativePath:String = directory.getRelativePath(file); // employees/bob/test.txt
relativePath = relativePath.replace(/\//g, File.separator);
trace(relativePath); 
</codeblock> 在此示例中，<codeph class="+ topic/ph pr-d/codeph ">replace()</codeph> 方法使用正则表达式 <codeph class="+ topic/ph pr-d/codeph ">/\//g</codeph> 与<i class="+ topic/ph hi-d/i ">所有</i> 正斜杠字符匹配。
</example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:spaceAvailable:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">spaceAvailable</apiName><shortdesc class="- topic/shortdesc ">
	 可用于在此 File 位置使用的空间，以字节为单位。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.1" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Number</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 可用于在此 File 位置使用的空间，以字节为单位。 
	 
	 <p class="- topic/p "> 如果 File 对象引用一个目录，则 <codeph class="+ topic/ph pr-d/codeph ">spaceAvailable</codeph> 将表示可供文件使用的目录空间。如果 File 对象引用一个文件，则 <codeph class="+ topic/ph pr-d/codeph ">spaceAvailable</codeph> 将表示可供该文件使用的空间。如果该文件位置不存在，则 <codeph class="+ topic/ph pr-d/codeph ">spaceAvailable</codeph> 将设置为 0。如果 File 对象引用一个符号链接，则 <codeph class="+ topic/ph pr-d/codeph ">spaceAvailable</codeph> 将表示符号链接指向的位置的可用空间。</p>
	 
	 <p class="- topic/p ">通常，目录或文件的可用空间与包含目录或文件的卷上的可用空间相同。不过，可用空间与磁盘配额及每个目录的空间限制有关。</p>
	 
	 <p class="- topic/p ">将文件或目录添加到卷中通常需要比文件的实际大小或目录中内容的实际大小更多的空间。例如，操作系统可能需要更多空间来存储索引信息。或者，所需的磁盘扇区可能会使用额外的空间。此外，可用空间是动态变化的。因此，您不能期望为文件存储分配报告的<i class="+ topic/ph hi-d/i ">全部</i> 空间。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:systemCharset:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">systemCharset</apiName><shortdesc class="- topic/shortdesc ">
	 主机操作系统使用的默认编码。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 主机操作系统使用的默认编码。 
	 
	 <p class="- topic/p ">可能值包括<codeph class="+ topic/ph pr-d/codeph ">“windows-1252”</codeph>、<codeph class="+ topic/ph pr-d/codeph ">“shift-jis”</codeph>、<codeph class="+ topic/ph pr-d/codeph ">“cn-gb”</codeph>、<codeph class="+ topic/ph pr-d/codeph ">“iso-8859-1”</codeph>等。有关完整列表，请参阅<xref href="../../charset-codes.html" class="- topic/xref ">支持的字符集</xref>。</p>
	 
	 <p class="- topic/p ">在使用 FileStream 类的 <codeph class="+ topic/ph pr-d/codeph ">readMultiByte()</codeph> 和 <codeph class="+ topic/ph pr-d/codeph ">writeMultiByte()</codeph> 方法时，可以使用此值。</p>
	 
	 </apiDesc><example conref="examples\File.systemCharSet.1.as" class="- topic/example "> 下面的代码打开一个文件（用户文档目录的 AIR Test 子目录中的 test.txt 文件），并使用 <codeph class="+ topic/ph pr-d/codeph ">File.systemCharset</codeph> 静态属性作为 FileStream 对象的 <codeph class="+ topic/ph pr-d/codeph ">readMultiByte()</codeph> 方法调用的 <codeph class="+ topic/ph pr-d/codeph ">charSet</codeph> 参数。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var file:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.READ);
var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
trace(str);    
</codeblock></example></apiValueDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#FileStream/readMultiByte()" class="- topic/link "><linktext class="- topic/linktext ">FileStream.readMultiByte()</linktext></link><link href="flash.filesystem.xml#FileStream/writeMultiByte()" class="- topic/link "><linktext class="- topic/linktext ">FileStream.writeMultiByte()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:url:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">url</apiName><shortdesc class="- topic/shortdesc ">
	 此文件路径的 URL。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata><asCustoms class="+ topic/metadata adobe-api-d/asCustoms "><internal>The URL will have a null "host" specification. (As opposed to "localhost". This is more confusing than 
	 informative.
	 
	 </internal></asCustoms></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="readwrite" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">URL 语法无效。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">ArgumentError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">ArgumentError</apiOperationClassifier></apiException><apiException class="+ topic/ph reference/ph apiRef/apiDefItem apiOperation/apiEvent adobe-api-d/apiException "><apiDesc class="- topic/section reference/section apiRef/apiDesc ">调用方不在应用程序安全沙箱中。
	 
	 </apiDesc><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">SecurityError</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 此文件路径的 URL。
	 
	 <p class="- topic/p ">如果这是对应用程序存储目录中的路径的引用，则 URL 架构为 <codeph class="+ topic/ph pr-d/codeph ">"app-storage"</codeph>；如果这是对应用程序目录中路径的引用，则 URL 架构为 <codeph class="+ topic/ph pr-d/codeph ">"app"</codeph>；否则此架构为 <codeph class="+ topic/ph pr-d/codeph ">"file"</codeph>。 </p>
	 
	 <p class="- topic/p ">在向 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性<i class="+ topic/ph hi-d/i ">赋</i>值时，可以使用空格字符（而不是 <codeph class="+ topic/ph pr-d/codeph ">"%20"</codeph>）；AIR 会自动对该字符串进行编码（例如，将空格转换为 <codeph class="+ topic/ph pr-d/codeph ">"%20"</codeph>）。</p>
	 
	 </apiDesc><example conref="examples\File.nativePath.1.as" class="- topic/example "> 下面的代码显示 File 对象的 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 属性和 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性之间的区别。注释将在示例 Windows 计算机上显示结果。
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var docs:File = File.documentsDirectory;
trace(docs.nativePath); // C:\Documents and Settings\turing\My Documents
trace(docs.url); // file:///C:/Documents%20and%20Settings/turing/My%20Documents
</codeblock></example></apiValueDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#File/nativePath" class="- topic/link "><linktext class="- topic/linktext ">nativePath</linktext></link><link href="../../package.html#decodeURI()" class="- topic/link "><linktext class="- topic/linktext ">decodeURI() 全局函数</linktext></link><link href="../../package.html#decodeURIComponent()" class="- topic/link "><linktext class="- topic/linktext ">decodeURIComponent() 全局函数</linktext></link><link href="../../package.html#encodeURI()" class="- topic/link "><linktext class="- topic/linktext ">decodeURI() 全局函数</linktext></link><link href="../../package.html#encodeURIComponent()" class="- topic/link "><linktext class="- topic/linktext ">decodeURIComponent() 全局函数</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:userDirectory:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">userDirectory</apiName><shortdesc class="- topic/shortdesc ">
	 用户目录。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="1.0" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	 用户目录。
	 
	 <p class="- topic/p ">在 Windows 中，这是“My Documents”目录的父级（例如，C:\Documents and Settings\userName）。在 Mac OS 中，它是 /Users/userName. 在 Linux 中，它是 /home/userName。</p>
	 
	 <p class="- topic/p "><codeph class="+ topic/ph pr-d/codeph ">userDirectory</codeph> 属性可用于引用用户目录，它在所有平台上均有效。如果直接设置 File 对象的 <codeph class="+ topic/ph pr-d/codeph ">nativePath</codeph> 或 <codeph class="+ topic/ph pr-d/codeph ">url</codeph> 属性，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 <p class="- topic/p ">如果操作系统不支持用户目录，则使用文件系统中适当的目录。</p>
	 
     <p class="- topic/p ">在用于电视的 AIR 设备上，<codeph class="+ topic/ph pr-d/codeph ">userDirectory</codeph> 属性引用对于应用程序是唯一的用户目录。</p>	
     
	 </apiDesc><example conref="examples\File.userDirectory.1.as" class="- topic/example "> 下面的代码输出用户目录的根级别包含的文件和目录的列表：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
import flash.filesystem.File;

var files:Array = File.userDirectory.listDirectory();
for (var i:uint = 0; i &lt; files.length; i++) {
    trace(files[i].nativePath);
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier languages="" id="flash.filesystem:StorageVolume" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiClassifier/apiClassifier "><apiName class="- topic/title reference/title apiRef/apiName ">StorageVolume</apiName><shortdesc class="- topic/shortdesc ">
      StorageVolume 对象包括定义大容量存储卷的属性。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiClassifierDetail class="- topic/body reference/refbody apiRef/apiDetail apiClassifier/apiClassifierDetail "><apiClassifierDef class="- topic/section reference/section apiRef/apiDef apiClassifier/apiClassifierDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiStatic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiStatic "/><apiBaseClassifier class="- topic/xref reference/xref apiRef/apiRelation apiClassifier/apiBaseClassifier ">Object</apiBaseClassifier></apiClassifierDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
      StorageVolume 对象包括定义大容量存储卷的属性。此类有两种使用方式：
      
      <ul class="- topic/ul "><li class="- topic/li ">StorageVolumeChangeEvent 对象的 <codeph class="+ topic/ph pr-d/codeph ">storageVolume</codeph> 属性是 StorageVolume 对象。此对象表示已安装或已卸载的存储卷。</li><li class="- topic/li "><codeph class="+ topic/ph pr-d/codeph ">StorageVolumeInfo.storageVolumeInfo.getStorageVolumes()</codeph> 方法返回 StorageVolume 对象的一个矢量。每个 StorageVolume 对象分别表示一个安装的存储卷。</li></ul>
      
      </apiDesc><example conref="examples\StorageVolumeExample.as" class="- topic/example "> 以下代码列出每个安装的存储卷的属性：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
package
{
    import flash.display.Sprite;
    import flash.filesystem.StorageVolume;
    import flash.filesystem.StorageVolumeInfo;

    public class StorageVolumeExample extends Sprite
    {
        public function StorageVolumeExample()
        {
            var volumes:Vector.&lt;StorageVolume> = StorageVolumeInfo.storageVolumeInfo.getStorageVolumes();
            for (var i:int = 0; i &lt; volumes.length; i++)
            {
                var volume:StorageVolume = volumes[i];
                trace("nativePath:", volume.rootDirectory.nativePath);
                trace("fileSystemType:", volume.fileSystemType);
                trace("isRemovable:", volume.isRemovable);
                trace("isWritable:", volume.isWritable);
                trace("drive:", volume.drive);
                trace("name:", volume.name);
                trace("________________________________________________________");
            }
        }
    }
}
</codeblock></example><example conref="examples\StorageVolumeChangeEventExample.as" class="- topic/example "> 以下代码列出每个已安装或已卸载的存储卷的属性。请注意，仅为 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeMount</codeph> 事件设置 StorageVolumeChangeEvent 的 <codeph class="+ topic/ph pr-d/codeph ">storageVolume</codeph> 属性；对于 <codeph class="+ topic/ph pr-d/codeph ">storageVolumeUnmount</codeph> 事件，该属性为 <codeph class="+ topic/ph pr-d/codeph ">null</codeph>：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
package
{
    import flash.display.Sprite;
    import flash.events.StorageVolumeChangeEvent;
    import flash.filesystem.StorageVolume;
    import flash.filesystem.StorageVolumeInfo;

    public class StorageVolumeChangeEventExample extends Sprite
    {
        public function StorageVolumeChangeEventExample()
        {
            StorageVolumeInfo.storageVolumeInfo.addEventListener(StorageVolumeChangeEvent.STORAGE_VOLUME_MOUNT, mountEventHandler);
            StorageVolumeInfo.storageVolumeInfo.addEventListener(StorageVolumeChangeEvent.STORAGE_VOLUME_UNMOUNT, unmountEventHandler);
        }
        public function mountEventHandler(event:StorageVolumeChangeEvent):void
        {            
            var volume:StorageVolume = event.storageVolume;
            trace("VOLUME MOUNTED:");
            trace("nativePath:", event.rootDirectory.nativePath);
            trace("fileSystemType:", volume.fileSystemType);
            trace("isRemovable:", volume.isRemovable);
            trace("isWritable:", volume.isWritable);
            trace("drive:", volume.drive);
            trace("name:", volume.name);
            trace();
        }
        public function unmountEventHandler(event:StorageVolumeChangeEvent):void
        {            
            trace("VOLUME UNMOUNTED:");
            trace("nativePath:", event.rootDirectory.nativePath);
            trace();
        }        
    }
}
</codeblock></example></apiClassifierDetail><related-links class="- topic/related-links "><link href="flash.filesystem.xml#StorageVolumeInfo/getStorageVolumes()" class="- topic/link "><linktext class="- topic/linktext ">flash.filesystem.StorageVolumeInfo.getStorageVolumes()</linktext></link><link href="flash.events.xml#StorageVolumeChangeEvent/storageVolume" class="- topic/link "><linktext class="- topic/linktext ">flash.events.StorageVolumeChangeEvent.storageVolume</linktext></link></related-links><apiConstructor id="flash.filesystem:StorageVolume:StorageVolume" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiOperation/apiOperation apiOperation/apiConstructor"><apiName class="- topic/title reference/title apiRef/apiName ">StorageVolume</apiName><shortdesc class="- topic/shortdesc "> 
	    构造函数。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiConstructorDetail class="- topic/body reference/refbody apiRef/apiDetail apiOperation/apiOperationDetail apiOperation/apiConstructorDetail"><apiConstructorDef class="- topic/section reference/section apiRef/apiDef apiOperation/apiConstructorDef "><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">rootDirPath</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">flash.filesystem:File</apiOperationClassifier></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">name</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">writable</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">removable</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">Boolean</apiOperationClassifier></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">fileSysType</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier></apiParam><apiParam class="- topic/ph reference/ph apiRef/apiDefItem apiOperation/apiParam "><apiItemName class="- topic/keyword reference/keyword apiRef/apiItemName ">drive</apiItemName><apiOperationClassifier class="- topic/xref reference/xref apiRef/apiRelation apiOperation/apiOperationClassifier ">String</apiOperationClassifier></apiParam></apiConstructorDef><apiDesc class="- topic/section reference/section apiRef/apiDesc "> 
	    构造函数。通常，您不直接调用此构造函数（以创建新的 StorageVolume 对象），而是通过访问 StorageVolumeChangeEvent 对象的 <codeph class="+ topic/ph pr-d/codeph ">storageVolume</codeph> 属性或调用 <codeph class="+ topic/ph pr-d/codeph ">StorageVolumeInfo.storageVolumeInfo.getStorageVolumes()</codeph> 来引用 StorageVolume 对象。
	    
	    </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.filesystem:StorageVolume:drive:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">drive</apiName><shortdesc class="- topic/shortdesc ">
	     Windows 上的卷驱动器号。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	     Windows 上的卷驱动器号。在其他平台上，此属性设置为 <codeph class="+ topic/ph pr-d/codeph ">null</codeph>。
	     
	     </apiDesc><example conref="examples\StorageVolume.drive.1.as" class="- topic/example "/></apiValueDetail></apiValue><apiValue id="flash.filesystem:StorageVolume:fileSystemType:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">fileSystemType</apiName><shortdesc class="- topic/shortdesc "> 
             存储卷上的文件系统类型（如“FAT”、“NTFS”、“HFS”或“UFS”）。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc "> 
             存储卷上的文件系统类型（如<codeph class="+ topic/ph pr-d/codeph ">“FAT”</codeph>、<codeph class="+ topic/ph pr-d/codeph ">“NTFS”</codeph>、<codeph class="+ topic/ph pr-d/codeph ">“HFS”</codeph>或<codeph class="+ topic/ph pr-d/codeph ">“UFS”</codeph>）。
             
	     </apiDesc><example conref="examples\StorageVolume.fileSystemType.1.as" class="- topic/example "> 以下代码列出根目录的本机路径和每个安装的存储卷的文件系统类型：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
var volumes:Vector.&lt;StorageVolume> = new Vector.&lt;StorageVolume>;
volumes = StorageVolumeInfo.storageVolumeInfo.getStorageVolumes();
for (var i:int = 0; i &lt; volumes.length; i++)
{
    trace(volumes[i].rootDirectory.nativePath, "(" + volumes[i].fileSystemType + ")");
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:StorageVolume:isRemovable:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">isRemovable</apiName><shortdesc class="- topic/shortdesc ">
             操作系统将存储卷视为可删除 (true) 还是不可删除 (false)。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
             操作系统将存储卷视为可删除 (<codeph class="+ topic/ph pr-d/codeph ">true</codeph>) 还是不可删除 (<codeph class="+ topic/ph pr-d/codeph ">false</codeph>)。
             
             <p class="- topic/p ">下表列出了各种设备类型的 <codeph class="+ topic/ph pr-d/codeph ">StorageVolume.isRemovable</codeph> 属性的值：</p>
             
	     <adobetable class="innertable"><tgroup cols="4" class="- topic/tgroup "><thead class="- topic/thead "><row class="- topic/row "><entry class="- topic/entry ">设备类型</entry><entry class="- topic/entry ">Mac OS</entry><entry class="- topic/entry ">Windows</entry><entry class="- topic/entry ">Linux</entry></row></thead><tbody class="- topic/tbody "><row align="center" class="- topic/row "><entry align="left" class="- topic/entry ">CD/DVD（固定）</entry><entry align="center" class="- topic/entry ">true</entry><entry align="center" class="- topic/entry ">true</entry><entry align="center" class="- topic/entry ">true</entry></row><row align="center" class="- topic/row "><entry align="left" class="- topic/entry ">USB 闪存驱动器</entry><entry align="center" class="- topic/entry ">true</entry><entry align="center" class="- topic/entry ">true</entry><entry align="center" class="- topic/entry ">true</entry></row><row align="center" class="- topic/row "><entry align="left" class="- topic/entry ">USB 硬盘驱动器</entry><entry align="center" class="- topic/entry ">false</entry><entry align="center" class="- topic/entry ">false</entry><entry align="center" class="- topic/entry ">true</entry></row><row align="center" class="- topic/row "><entry align="left" class="- topic/entry ">FireWire 硬盘驱动器</entry><entry align="center" class="- topic/entry ">false</entry><entry align="center" class="- topic/entry ">false</entry><entry align="center" class="- topic/entry ">true</entry></row><row align="center" class="- topic/row "><entry align="left" class="- topic/entry ">共享卷</entry><entry align="center" class="- topic/entry ">true</entry><entry align="center" class="- topic/entry ">false</entry><entry align="center" class="- topic/entry ">- <sup class="+ topic/ph hi-d/sup ">1</sup></entry></row><row align="center" class="- topic/row "><entry align="left" class="- topic/entry ">网络驱动器</entry><entry align="center" class="- topic/entry ">false</entry><entry align="center" class="- topic/entry ">false</entry><entry align="center" class="- topic/entry ">false</entry></row><row align="center" class="- topic/row "><entry align="left" class="- topic/entry ">存储卡读取器（空）</entry><entry align="center" class="- topic/entry ">- <sup class="+ topic/ph hi-d/sup ">2</sup></entry><entry align="center" class="- topic/entry ">false</entry><entry align="center" class="- topic/entry ">- <sup class="+ topic/ph hi-d/sup ">2</sup></entry></row><row align="center" class="- topic/row "><entry align="left" class="- topic/entry ">存储卡读取器（带有 SD/CF 卡）</entry><entry align="center" class="- topic/entry ">true</entry><entry align="center" class="- topic/entry ">true</entry><entry align="center" class="- topic/entry ">true</entry></row></tbody></tgroup></adobetable>
	     
	     <p class="- topic/p "><sup class="+ topic/ph hi-d/sup ">1</sup> Linux 没有共享卷的概念。</p>
	     
	     <p class="- topic/p "><sup class="+ topic/ph hi-d/sup ">2</sup> 在 Windows 上，空读卡器作为不可移除的设备列出。在 Mac OS 和 Linux 上，空读卡器不作为存储卷列出。</p>
             
	     </apiDesc><example conref="examples\StorageVolume.isRemovable.1.as" class="- topic/example "> 以下代码依次输出不可删除存储卷的列表和可删除存储卷的列表：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
var volumes:Vector.&lt;StorageVolume> = new Vector.&lt;StorageVolume>;
volumes = StorageVolumeInfo.storageVolumeInfo.getStorageVolumes();

trace("Non-removeable volumes:");
for (var i:int = 0; i &lt; volumes.length; i++)
{
    if (!volumes[i].isRemovable)
    {
        trace(volumes[i].rootDirectory.nativePath);
    }
}

trace("\nRemoveable volumes:");
for (i = 0; i &lt; volumes.length; i++)
{
    if (volumes[i].isRemovable)
    {
        trace(volumes[i].rootDirectory.nativePath);
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:StorageVolume:isWritable:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">isWritable</apiName><shortdesc class="- topic/shortdesc ">
             卷是可写 (true) 还是不可写 (false)。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">Boolean</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
             卷是可写 (<codeph class="+ topic/ph pr-d/codeph ">true</codeph>) 还是不可写 (<codeph class="+ topic/ph pr-d/codeph ">false</codeph>)。
             
             <p class="- topic/p "><b class="+ topic/ph hi-d/b ">注意：</b>可通过调用 StorageVolume 对象的 <codeph class="+ topic/ph pr-d/codeph ">rootDirectory.spaceAvailble</codeph> 属性确定卷上的可用空间量。</p>
             
             </apiDesc><example conref="examples\StorageVolume.isWritable.1.as" class="- topic/example "> 以下代码输出可写存储卷列表及每个卷上的可用空间：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
var volumes:Vector.&lt;StorageVolume> = new Vector.&lt;StorageVolume>;
volumes = StorageVolumeInfo.storageVolumeInfo.getStorageVolumes();

for (var i:int = 0; i &lt; volumes.length; i++)
{
    if(volumes[i].isWritable)
    {         
        trace(volumes[i].rootDirectory.nativePath, volumes[i].rootDirectory.spaceAvailable);
    }
}
</codeblock></example></apiValueDetail><related-links class="- topic/related-links "><link href="" invalidHref="flash.fileSystem.File.spaceAvailable.xml" class="- topic/link "><linktext class="- topic/linktext ">flash.fileSystem.File.spaceAvailable</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:StorageVolume:name:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">name</apiName><shortdesc class="- topic/shortdesc ">
	     卷的名称。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">String</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	     卷的名称。如果没有名称，此属性设置为 <codeph class="+ topic/ph pr-d/codeph ">null</codeph>。
	     
	     </apiDesc><example conref="examples\StorageVolume.name.1.as" class="- topic/example "> 以下代码列出根目录的本机路径及每个安装的存储卷的文件系统名称（如果有）：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
var volumes:Vector.&lt;StorageVolume> = new Vector.&lt;StorageVolume>;
volumes = StorageVolumeInfo.storageVolumeInfo.getStorageVolumes();
for (var i:int = 0; i &lt; volumes.length; i++)
{
    var name:String = new String();
    if (volumes[i].name)
    {
        name = "(" + volumes[i].name + ")";
    }
    trace(volumes[i].rootDirectory.nativePath, name);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:StorageVolume:rootDirectory:get" ditaarch:DITAArchVersion="1.0" domains="(topic ui-d) (topic hi-d) (topic pr-d) (topic sw-d)                              (topic ut-d) (topic pr-d api-d)" class="- topic/topic reference/reference apiRef/apiRef apiValue/apiValue "><apiName class="- topic/title reference/title apiRef/apiName ">rootDirectory</apiName><shortdesc class="- topic/shortdesc ">
	     与卷的根目录对应的 File 对象。</shortdesc><prolog class="- topic/prolog "><asMetadata class="+ topic/metadata adobe-api-d/asMetadata "><apiVersion class="+ topic/ph adobe-api-d/apiVersion "><apiLanguage version="3.0" class="+ topic/ph adobe-api-d/apiLanguage "/><apiPlatform description="" name="AIR" version="2" class="+ topic/ph adobe-api-d/apiPlatform "/></apiVersion></asMetadata></prolog><apiValueDetail class="- topic/body reference/refbody apiRef/apiDetail apiValue/apiValueDetail "><apiValueDef class="- topic/section reference/section apiRef/apiDef apiValue/apiValueDef "><apiProperty class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiProperty "/><apiAccess value="public" class="- topic/state reference/state apiRef/apiQualifier adobe-api-d/apiAccess "/><apiDynamic class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiDynamic "/><apiValueAccess value="read" class="+ topic/state reference/state apiRef/apiQualifier adobe-api-d/apiValueAccess "/><apiValueClassifier class="- topic/xref reference/xref apiRef/apiRelation apiValue/apiValueClassifier ">flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc class="- topic/section reference/section apiRef/apiDesc ">
	     与卷的根目录对应的 File 对象。
	     
	     </apiDesc><example conref="examples\StorageVolume.rootDirectory.1.as" class="- topic/example "> 下列代码列出了每个装载的存储卷的根目录的本机路径：
<codeblock xml:space="preserve" class="+ topic/pre pr-d/codeblock ">
var volumes:Vector.&lt;StorageVolume> = new Vector.&lt;StorageVolume>;
volumes = StorageVolumeInfo.storageVolumeInfo.getStorageVolumes();
for (var i:int = 0; i &lt; volumes.length; i++)
{
    trace(volumes[i].rootDirectory.nativePath);
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier></apiPackage>